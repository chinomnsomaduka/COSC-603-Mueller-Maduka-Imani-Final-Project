<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>Unit.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">TestAll (6) (May 17, 2016 2:04:14 AM)</a> &gt; <a href="../../index.html" class="el_group">FreeCol</a> &gt; <a href="../index.html" class="el_bundle">src</a> &gt; <a href="index.source.html" class="el_package">net.sf.freecol.common.model</a> &gt; <span class="el_source">Unit.java</span></div><h1>Unit.java</h1><pre class="source lang-java linenums"><span class="nc" id="L1">/**</span>
 *  Copyright (C) 2002-2016   The FreeCol Team
 *
 *  This file is part of FreeCol.
 *
 *  FreeCol is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  FreeCol is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with FreeCol.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package net.sf.freecol.common.model;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.logging.Logger;

import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;

import net.sf.freecol.common.i18n.Messages;
import net.sf.freecol.common.io.FreeColXMLReader;
import net.sf.freecol.common.io.FreeColXMLWriter;
import net.sf.freecol.common.model.CombatModel;
import net.sf.freecol.common.model.Direction;
import net.sf.freecol.common.model.pathfinding.CostDecider;
import net.sf.freecol.common.model.pathfinding.CostDeciders;
import net.sf.freecol.common.model.pathfinding.GoalDecider;
import net.sf.freecol.common.model.pathfinding.GoalDeciders;
import net.sf.freecol.common.model.UnitTypeChange.ChangeType;
import net.sf.freecol.common.networking.DOMMessage;
import static net.sf.freecol.common.util.CollectionUtils.*;
import static net.sf.freecol.common.util.StringUtils.*;

import org.w3c.dom.Element;

/**
 * Represents all pieces that can be moved on the map-board. This includes:
 * colonists, ships, wagon trains e.t.c.
 *
 * Every &lt;code&gt;Unit&lt;/code&gt; is owned by a {@link Player} and has a
 * {@link Location}.
 */
public class Unit extends GoodsLocation implements Consumer, Locatable,
		Movable, Nameable, Ownable {

<span class="fc" id="L61">	private static final Logger logger = Logger.getLogger(Unit.class.getName());</span>

	/**
	 * A large number of turns, denoting pathfinding failure. Do not use
	 * INFINITY as further calculation might use this.
	 */
	public static final int MANY_TURNS = 10000;

	public static final String CARGO_CHANGE = &quot;CARGO_CHANGE&quot;;
	public static final String MOVE_CHANGE = &quot;MOVE_CHANGE&quot;;
	public static final String ROLE_CHANGE = &quot;ROLE_CHANGE&quot;;

	/** Compare units by location. */
<span class="fc" id="L74">	public static final Comparator&lt;Unit&gt; locComparator = Comparator</span>
<span class="pc" id="L75">			.comparingInt(u -&gt; Location.getRank(u));</span>

	/** A comparator to compare units by type then role. */
<span class="fc" id="L78">	public static final Comparator&lt;Unit&gt; typeRoleComparator = Comparator</span>
<span class="fc" id="L79">			.comparing(Unit::getType).thenComparing(</span>
<span class="fc" id="L80">					Comparator.comparing(Unit::getRole));</span>

	/** A state a Unit can have. */
<span class="nc" id="L83">	public static enum UnitState {</span>
<span class="nc" id="L84">		ACTIVE, FORTIFIED, SENTRY, IN_COLONY, IMPROVING,</span>
<span class="nc" id="L85">		// @compat 0.10.0</span>
<span class="nc" id="L86">		TO_EUROPE, TO_AMERICA,</span>
<span class="nc" id="L87">		// end @compat</span>
<span class="nc" id="L88">		FORTIFYING, SKIPPED;</span>

		/**
		 * Get the stem key for this unit state.
		 *
		 * @return The stem key.
		 */
		public String getKey() {
<span class="nc" id="L96">			return &quot;unitState.&quot; + getEnumKey(this);</span>
		}
	}

	/** The individual name of this unit, not of the unit type. */
<span class="nc" id="L101">	protected String name = null;</span>

	/** The owner player. */
	protected Player owner;

	/** The unit type. */
	protected UnitType unitType;

	/** Current unit state. */
<span class="nc" id="L110">	protected UnitState state = UnitState.ACTIVE;</span>

	/** Current unit role. */
	protected Role role;

	/**
	 * The amount of role-equipment this unit carries, subject to
	 * role.getMaximumCount(). Currently zero or one except for pioneers.
	 */
	protected int roleCount;

	/** The current unit location. */
	protected Location location;

	/** The last entry location used by this unit. */
	protected Location entryLocation;

	/** The number of moves this unit has left this turn. */
	protected int movesLeft;

	/** What type of goods this unit produces in its occupation. */
	protected GoodsType workType;

	/** What type of goods this unit last earned experience producing. */
	protected GoodsType experienceType;

	/** The mount of experience a unit has earned. */
<span class="nc" id="L137">	protected int experience = 0;</span>

	/**
	 * The number of turns until the work is finished (e.g. sailing, improving),
	 * or '-1' if a Unit can stay in its state forever.
	 */
	protected int workLeft;

	/**
	 * What is being improved (to be used only for PIONEERs - where they are
	 * working.
	 */
	protected TileImprovement workImprovement;

	/** The student of this Unit, if it has one. */
	protected Unit student;

	/** The teacher of this Unit, if it has one. */
	protected Unit teacher;

	/** Number of turns of training needed by this unit. */
<span class="nc" id="L158">	protected int turnsOfTraining = 0;</span>

	/** The original nationality. */
<span class="nc" id="L161">	protected String nationality = null;</span>

	/** The original ethnicity. */
<span class="nc" id="L164">	protected String ethnicity = null;</span>

	/** The home settlement of a native unit. */
<span class="nc" id="L167">	protected IndianSettlement indianSettlement = null;</span>

	/** For now; only used by ships when repairing. */
	protected int hitPoints;

	/** A destination for go-to moves. */
<span class="nc" id="L173">	protected Location destination = null;</span>

	/** The trade route this unit has. */
<span class="nc" id="L176">	protected TradeRoute tradeRoute = null;</span>

	/** Which stop in a trade route the unit is going to. */
<span class="nc" id="L179">	protected int currentStop = -1;</span>

	/** To be used only for type == TREASURE_TRAIN */
	protected int treasureAmount;

	/**
	 * The attrition this unit has accumulated. At the moment, this equals the
	 * number of turns it has spent in the open.
	 */
<span class="nc" id="L188">	protected int attrition = 0;</span>

	/**
	 * The amount of goods carried by this unit. This variable is only used by
	 * the clients. A negative value signals that the variable is not in use.
	 *
	 * @see #getVisibleGoodsCount()
	 */
	protected int visibleGoodsCount;

	/**
	 * Constructor for ServerUnit.
	 *
	 * @param game
	 *            The enclosing &lt;code&gt;Game&lt;/code&gt;.
	 */
	protected Unit(Game game) {
<span class="nc" id="L205">		super(game);</span>
<span class="nc" id="L206">	}</span>

	/**
	 * Initialize this object from an XML-representation of this object.
	 *
	 * @param game
	 *            The enclosing &lt;code&gt;Game&lt;/code&gt;.
	 * @param e
	 *            An XML-element that will be used to initialize this object.
	 */
	public Unit(Game game, Element e) {
<span class="nc" id="L217">		super(game, null);// Must override identifier when called client side</span>

<span class="nc" id="L219">		DOMMessage.readFromXMLElement(this, e);</span>
<span class="nc" id="L220">	}</span>

	/**
	 * Creates a new &lt;code&gt;Unit&lt;/code&gt; with the given identifier. The object
	 * should later be initialized by calling
	 * {@link #readFromXML(FreeColXMLReader)}.
	 *
	 * @param game
	 *            The enclosing &lt;code&gt;Game&lt;/code&gt;.
	 * @param id
	 *            The object identifier.
	 */
	public Unit(Game game, String id) {
<span class="nc" id="L233">		super(game, id);</span>
<span class="nc" id="L234">	}</span>

	/**
	 * Get the individual name of this unit.
	 *
	 * @return The individual name.
	 */
	@Override
	public String getName() {
<span class="nc" id="L243">		return name;</span>
	}

	/**
	 * Set the individual name of this unit.
	 *
	 * @param newName
	 *            The new name.
	 */
	@Override
	public void setName(String newName) {
<span class="nc" id="L254">		this.name = newName;</span>
<span class="nc" id="L255">	}</span>

	/**
	 * Get the name of the apparent owner of this Unit, (like
	 * getOwner().getNationAsString() but handles pirates).
	 *
	 * @return The name of the apparent owner of this &lt;code&gt;Unit&lt;/code&gt;.
	 */
	public StringTemplate getApparentOwnerName() {
<span class="nc bnc" id="L264" title="All 2 branches missed.">		Player own = (hasAbility(Ability.PIRACY)) ? getGame().getUnknownEnemy()</span>
<span class="nc" id="L265">				: owner;</span>
<span class="nc" id="L266">		return own.getNationLabel();</span>
	}

	/** What type of unit label do we want? */
<span class="nc" id="L270">	public static enum UnitLabelType {</span>
<span class="nc" id="L271">		PLAIN, // Just the basics</span>
<span class="nc" id="L272">		NATIONAL, // Add the nation</span>
<span class="nc" id="L273">		FULL // Add the equipment and extras</span>
	}

	/**
	 * Get a plain string template for a unit.
	 *
	 * @return The &lt;code&gt;StringTemplate&lt;/code&gt; to describe the given unit.
	 */
	public StringTemplate getLabel() {
<span class="nc" id="L282">		return getLabel(UnitLabelType.PLAIN);</span>
	}

	/**
	 * Get a string template for a unit.
	 *
	 * The PLAIN template contains: - The type of the unit - A role if not the
	 * default - The specific name of the unit if it has one The NATIONAL
	 * template adds the nation The FULL template adds equipment annotations
	 *
	 * @param ult
	 *            The type of label to get.
	 * @return The &lt;code&gt;StringTemplate&lt;/code&gt; to describe the given unit.
	 */
	public StringTemplate getLabel(UnitLabelType ult) {
<span class="nc" id="L297">		final UnitType type = getType();</span>
<span class="nc" id="L298">		final Role role = getRole();</span>
<span class="nc" id="L299">		final Player owner = getOwner();</span>
<span class="nc bnc" id="L300" title="All 6 branches missed.">		if (type == null || role == null || owner == null) {</span>
<span class="nc" id="L301">			return null; // Probably disposed</span>
		}

<span class="nc bnc" id="L304" title="All 4 branches missed.">		switch (ult) {</span>
		case PLAIN:
<span class="nc" id="L306">			return Messages.getUnitLabel(getName(), type.getId(), 1, null,</span>
<span class="nc" id="L307">					role.getId(), null);</span>

		case NATIONAL:
<span class="nc bnc" id="L310" title="All 2 branches missed.">			if (role.getMaximumCount() &gt; 1) {</span>
				// If the amount of equipment can vary an equipment
				// label is required, so fall through into the FULL case.
			} else {
<span class="nc" id="L314">				return Messages.getUnitLabel(getName(), type.getId(), 1,</span>
<span class="nc" id="L315">						owner.getNationId(), role.getId(), null);</span>
			}
			// Fall through

		case FULL:
<span class="nc" id="L320">			StringTemplate extra = null;</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">			if (role.isDefaultRole()) {</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">				if (canCarryTreasure()) {</span>
<span class="nc" id="L323">					extra = StringTemplate.template(&quot;goldAmount&quot;).addAmount(</span>
<span class="nc" id="L324">							&quot;%amount%&quot;, getTreasureAmount());</span>
<span class="nc" id="L325">				} else {</span>
					// unequipped expert has no-equipment label
<span class="nc" id="L327">					List&lt;Role&gt; expertRoles = type.getExpertRoles();</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">					for (Role someRole : expertRoles) {</span>
<span class="nc" id="L329">						String key = someRole.getId() + &quot;.noequipment&quot;;</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">						if (Messages.containsKey(key)) {</span>
<span class="nc" id="L331">							extra = StringTemplate.key(key);</span>
<span class="nc" id="L332">							break;</span>
						}
					}
				}
<span class="nc" id="L336">			} else {</span>
<span class="nc" id="L337">				String equipmentKey = role.getId() + &quot;.equipment&quot;;</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">				if (Messages.containsKey(equipmentKey)) {</span>
					// Currently only used for missionary which does not
					// have equipment that directly corresponds to goods.
<span class="nc" id="L341">					extra = AbstractGoods.getLabel(equipmentKey, 1);</span>
<span class="nc" id="L342">				} else {</span>
					// Other roles can be characterized by their goods.
<span class="nc" id="L344">					List&lt;AbstractGoods&gt; requiredGoods = role</span>
<span class="nc" id="L345">							.getRequiredGoods(getRoleCount());</span>
<span class="nc" id="L346">					boolean first = true;</span>
<span class="nc" id="L347">					extra = StringTemplate.label(&quot;&quot;);</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">					for (AbstractGoods ag : requiredGoods) {</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">						if (first)</span>
<span class="nc" id="L350">							first = false;</span>
						else
<span class="nc" id="L352">							extra.addName(&quot; &quot;);</span>
<span class="nc" id="L353">						extra.addStringTemplate(ag.getLabel());</span>
					}
				}
			}
<span class="nc" id="L357">			return Messages.getUnitLabel(getName(), type.getId(), 1,</span>
<span class="nc" id="L358">					owner.getNationId(), role.getId(), extra);</span>
		default: // Can not happen
			break;
		}
<span class="nc" id="L362">		return null;</span>
	}

	/**
	 * Get the basic i18n description for this unit.
	 *
	 * @return A &lt;code&gt;String&lt;/code&gt; describing this unit.
	 */
	public String getDescription() {
<span class="nc" id="L371">		return Messages.message(getLabel());</span>
	}

	/**
	 * Get the basic i18n description for this unit.
	 *
	 * @param ult
	 *            The label type required.
	 * @return A &lt;code&gt;String&lt;/code&gt; describing this unit.
	 */
	public String getDescription(UnitLabelType ult) {
<span class="nc" id="L382">		return Messages.message(getLabel(ult));</span>
	}

	/**
	 * Get a label for the chance of success in a potential combat.
	 *
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to attack into.
	 * @return A suitable label.
	 */
	public StringTemplate getCombatLabel(Tile tile) {
<span class="nc" id="L393">		final CombatModel.CombatOdds combatOdds = getGame().getCombatModel()</span>
<span class="nc" id="L394">				.calculateCombatOdds(this, tile.getDefendingUnit(this));</span>
		// If attacking a settlement, the true odds are never
		// known because units may be hidden within
<span class="nc bnc" id="L397" title="All 2 branches missed.">		boolean unknown = combatOdds.win == CombatModel.CombatOdds.UNKNOWN_ODDS</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">				|| tile.hasSettlement();</span>
<span class="nc" id="L399">		return StringTemplate.template(&quot;model.unit.attackTileOdds&quot;)</span>
<span class="nc" id="L400">				.addName(</span>
<span class="nc" id="L401">						&quot;%chance%&quot;,</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">						(unknown) ? &quot;??&quot; : String</span>
<span class="nc" id="L403">								.valueOf((int) (combatOdds.win * 100)));</span>
	}

	/**
	 * Get a destination label for this unit.
	 *
	 * @return A &lt;code&gt;StringTemplate&lt;/code&gt; describing where this unit is
	 *         going.
	 */
	public StringTemplate getDestinationLabel() {
		// Create the right tag for the tagged &quot;goingTo&quot; message.
<span class="nc bnc" id="L414" title="All 4 branches missed.">		String type = (isPerson()) ? &quot;person&quot; : (isNaval()) ? &quot;ship&quot; : &quot;other&quot;;</span>
<span class="nc" id="L415">		return getDestinationLabel(type, getDestination(), getOwner());</span>
	}

	/**
	 * Get a destination label for a given unit tag, destination and player.
	 *
	 * @param tag
	 *            The unit tag for the &quot;goingTo&quot; message.
	 * @param destination
	 *            The destination &lt;code&gt;Location&lt;/code&gt;.
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt; viewpoint.
	 * @return A &lt;code&gt;StringTemplate&lt;/code&gt; describing the unit movement.
	 */
	public static StringTemplate getDestinationLabel(String tag,
			Location destination, Player player) {
<span class="nc" id="L431">		return StringTemplate</span>
<span class="nc" id="L432">				.template(&quot;model.unit.goingTo&quot;)</span>
<span class="nc" id="L433">				.addTagged(&quot;%type%&quot;, tag)</span>
<span class="nc" id="L434">				.addStringTemplate(&quot;%location%&quot;,</span>
<span class="nc" id="L435">						destination.getLocationLabelFor(player));</span>
	}

	/**
	 * Get a string template describing the repair state of this unit.
	 *
	 * @return A repair label.
	 */
	public StringTemplate getRepairLabel() {
<span class="nc" id="L444">		return StringTemplate.template(&quot;model.unit.underRepair&quot;).addAmount(</span>
<span class="nc" id="L445">				&quot;%turns%&quot;, getTurnsForRepair());</span>
	}

	/**
	 * Get the &lt;code&gt;UnitType&lt;/code&gt; value.
	 *
	 * @return The current &lt;code&gt;UnitType&lt;/code&gt;.
	 */
	public final UnitType getType() {
<span class="nc" id="L454">		return unitType;</span>
	}

	/**
	 * Sets the type of the unit.
	 *
	 * -vis: Has visibility issues as the line of sight may change.
	 *
	 * @param unitType
	 *            The new type of the unit.
	 */
	public void setType(UnitType unitType) {
<span class="nc" id="L466">		this.unitType = unitType;</span>
<span class="nc" id="L467">	}</span>

	/**
	 * Changes the type of the unit.
	 *
	 * -vis: Has visibility issues as the line of sight may change.
	 *
	 * @param unitType
	 *            The new type of the unit.
	 * @return True if the type change succeeds.
	 */
	public boolean changeType(UnitType unitType) {
<span class="nc bnc" id="L479" title="All 2 branches missed.">		if (!unitType.isAvailableTo(owner))</span>
<span class="nc" id="L480">			return false;</span>

<span class="nc" id="L482">		setType(unitType);</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">		if (getMovesLeft() &gt; getInitialMovesLeft()) {</span>
<span class="nc" id="L484">			setMovesLeft(getInitialMovesLeft());</span>
		}
<span class="nc" id="L486">		hitPoints = unitType.getHitPoints();</span>
<span class="nc bnc" id="L487" title="All 4 branches missed.">		if (getTeacher() != null &amp;&amp; !canBeStudent(getTeacher())) {</span>
<span class="nc" id="L488">			getTeacher().setStudent(null);</span>
<span class="nc" id="L489">			setTeacher(null);</span>
		}
<span class="nc" id="L491">		return true;</span>
	}

	/**
	 * Checks if this &lt;code&gt;Unit&lt;/code&gt; is naval.
	 *
	 * @return True if this is a naval &lt;code&gt;Unit&lt;/code&gt;.
	 */
	public boolean isNaval() {
<span class="nc bnc" id="L500" title="All 2 branches missed.">		return (unitType == null) ? false : unitType.isNaval();</span>
	}

	/**
	 * Checks if this unit is an undead.
	 *
	 * @return True if the unit is undead.
	 */
	public boolean isUndead() {
<span class="nc" id="L509">		return hasAbility(Ability.UNDEAD);</span>
	}

	/**
	 * Can this unit carry treasure (like a treasure train)?
	 *
	 * @return True if this &lt;code&gt;Unit&lt;/code&gt; can carry treasure.
	 */
	public boolean canCarryTreasure() {
<span class="nc" id="L518">		return hasAbility(Ability.CARRY_TREASURE);</span>
	}

	/**
	 * Can this unit capture enemy goods?
	 *
	 * @return True if this &lt;code&gt;Unit&lt;/code&gt; is capable of capturing goods.
	 */
	public boolean canCaptureGoods() {
<span class="nc" id="L527">		return hasAbility(Ability.CAPTURE_GOODS);</span>
	}

	/**
	 * Checks if this is a trading &lt;code&gt;Unit&lt;/code&gt;, meaning that it can trade
	 * with settlements.
	 *
	 * @return True if this is a trading unit.
	 */
	public boolean isTradingUnit() {
<span class="nc bnc" id="L537" title="All 4 branches missed.">		return canCarryGoods() &amp;&amp; owner.isEuropean();</span>
	}

	/**
	 * Checks if this &lt;code&gt;Unit&lt;/code&gt; is a `colonist'. A unit is a colonist if
	 * it is European and can build a new &lt;code&gt;Colony&lt;/code&gt;.
	 *
	 * @return True if this unit is a colonist.
	 */
	public boolean isColonist() {
<span class="nc bnc" id="L547" title="All 2 branches missed.">		return unitType.hasAbility(Ability.FOUND_COLONY)</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">				&amp;&amp; owner.hasAbility(Ability.FOUNDS_COLONIES);</span>
	}

	/**
	 * Checks if this &lt;code&gt;Unit&lt;/code&gt; is able to carry {@link Locatable}s.
	 *
	 * @return True if this unit can carry goods or other units.
	 */
	public boolean isCarrier() {
<span class="nc bnc" id="L557" title="All 4 branches missed.">		return unitType.canCarryGoods() || unitType.canCarryUnits();</span>
	}

	/**
	 * Checks if this unit is a person, that is not a ship or wagon.
	 * Surprisingly difficult without explicit enumeration because
	 * model.ability.person only arrived in 0.10.1.
	 *
	 * @return True if this unit is a person.
	 */
	public boolean isPerson() {
<span class="nc bnc" id="L568" title="All 2 branches missed.">		return hasAbility(Ability.PERSON)</span>
				// @compat 0.10.0
<span class="nc bnc" id="L570" title="All 2 branches missed.">				|| unitType.hasAbility(Ability.BORN_IN_COLONY)</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">				|| unitType.hasAbility(Ability.BORN_IN_INDIAN_SETTLEMENT)</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">				|| unitType.hasAbility(Ability.FOUND_COLONY)</span>
		// Nick also had:
		// &amp;&amp; (!hasAbility(&quot;model.ability.carryGoods&quot;)
		// &amp;&amp; !hasAbility(&quot;model.ability.carryUnits&quot;)
		// &amp;&amp; !hasAbility(&quot;model.ability.carryTreasure&quot;)
		// &amp;&amp; !hasAbility(&quot;model.ability.bombard&quot;))
		// ...but that should be unnecessary.
		// end @compat
		;
	}

	/**
	 * Gets the state of this &lt;code&gt;Unit&lt;/code&gt;.
	 *
	 * @return The state of this &lt;code&gt;Unit&lt;/code&gt;.
	 */
	public UnitState getState() {
<span class="nc" id="L589">		return state;</span>
	}

	/**
	 * Checks if a &lt;code&gt;Unit&lt;/code&gt; can get the given state set.
	 *
	 * @param s
	 *            The new state for this Unit. Should be one of
	 *            {UnitState.ACTIVE, FORTIFIED, ...}.
	 * @return True if the &lt;code&gt;Unit&lt;/code&gt; state can be changed to the new
	 *         value.
	 */
	public boolean checkSetState(UnitState s) {
<span class="nc bnc" id="L602" title="All 2 branches missed.">		if (getState() == s)</span>
<span class="nc" id="L603">			return false;</span>
<span class="nc bnc" id="L604" title="All 8 branches missed.">		switch (s) {</span>
		case ACTIVE:
<span class="nc" id="L606">			return true;</span>
		case FORTIFIED:
<span class="nc bnc" id="L608" title="All 2 branches missed.">			return getState() == UnitState.FORTIFYING;</span>
		case FORTIFYING:
<span class="nc bnc" id="L610" title="All 2 branches missed.">			return getMovesLeft() &gt; 0;</span>
		case IMPROVING:
<span class="nc bnc" id="L612" title="All 2 branches missed.">			return getMovesLeft() &gt; 0</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">					&amp;&amp; getLocation() instanceof Tile</span>
<span class="nc" id="L614">					&amp;&amp; getOwner().canAcquireForImprovement(</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">							getLocation().getTile());</span>
		case IN_COLONY:
<span class="nc bnc" id="L617" title="All 2 branches missed.">			return !isNaval();</span>
		case SENTRY:
<span class="nc" id="L619">			return true;</span>
		case SKIPPED:
<span class="nc bnc" id="L621" title="All 2 branches missed.">			return getState() == UnitState.ACTIVE;</span>
		default:
<span class="nc" id="L623">			logger.warning(&quot;Invalid unit state: &quot; + s);</span>
<span class="nc" id="L624">			return false;</span>
		}
	}

	/**
	 * Sets a new state for this unit and initializes the amount of work the
	 * unit has left.
	 *
	 * If the work needs turns to be completed (for instance when plowing), then
	 * the moves the unit has still left will be used up. Some work (basically
	 * building a road with a hardy pioneer) might actually be finished already
	 * in this method-call, in which case the state is set back to
	 * UnitState.ACTIVE.
	 *
	 * @param s
	 *            The new state for this Unit. Should be one of
	 *            {UnitState.ACTIVE, UnitState.FORTIFIED, ...}.
	 */
	public void setState(UnitState s) {
<span class="nc bnc" id="L643" title="All 2 branches missed.">		if (state == s) {</span>
			// No need to do anything when the state is unchanged
<span class="nc" id="L645">			return;</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">		} else if (!checkSetState(s)) {</span>
<span class="nc" id="L647">			throw new IllegalStateException(&quot;Illegal UnitState transition: &quot;</span>
<span class="nc" id="L648">					+ state + &quot; -&gt; &quot; + s);</span>
		} else {
<span class="nc" id="L650">			setStateUnchecked(s);</span>
		}
<span class="nc" id="L652">	}</span>

	/**
	 * Actually set the unit state.
	 *
	 * @param s
	 *            The new &lt;code&gt;UnitState&lt;/code&gt;.
	 */
	protected void setStateUnchecked(UnitState s) {
		// FIXME: move to the server.
		// Cleanup the old UnitState, for example destroy the
		// TileImprovment being built by a pioneer.
<span class="nc bnc" id="L664" title="All 2 branches missed.">		switch (state) {</span>
		case IMPROVING:
<span class="nc bnc" id="L666" title="All 4 branches missed.">			if (workImprovement != null &amp;&amp; getWorkLeft() &gt; 0) {</span>
				// Remove the tile improvement if it is incomplete
				// and no one else is working on it
				Tile tile;
<span class="nc bnc" id="L670" title="All 2 branches missed.">				if (!workImprovement.isComplete()</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">						&amp;&amp; (tile = workImprovement.getTile()) != null</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">						&amp;&amp; tile.getTileItemContainer() != null</span>
<span class="nc" id="L673">						&amp;&amp; none(tile.getUnitList(),</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">								u -&gt; u != this</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">										&amp;&amp; u.getState() == UnitState.IMPROVING</span>
<span class="nc bnc" id="L676" title="All 4 branches missed.">										&amp;&amp; u.getWorkImprovement() == workImprovement)) {</span>
<span class="nc" id="L677">					workImprovement.getTile().getTileItemContainer()</span>
<span class="nc" id="L678">							.removeTileItem(workImprovement);</span>
				}
<span class="nc" id="L680">				setWorkImprovement(null);</span>
			}
<span class="nc" id="L682">			break;</span>
		default:
			// do nothing
<span class="nc" id="L685">			break;</span>
		}

		// Now initiate the new UnitState
<span class="nc bnc" id="L689" title="All 7 branches missed.">		switch (s) {</span>
		case ACTIVE:
<span class="nc" id="L691">			setWorkLeft(-1);</span>
<span class="nc" id="L692">			break;</span>
		case SENTRY:
<span class="nc" id="L694">			setWorkLeft(-1);</span>
<span class="nc" id="L695">			break;</span>
		case FORTIFIED:
<span class="nc" id="L697">			setWorkLeft(-1);</span>
<span class="nc" id="L698">			movesLeft = 0;</span>
<span class="nc" id="L699">			break;</span>
		case FORTIFYING:
<span class="nc" id="L701">			setWorkLeft(1);</span>
<span class="nc" id="L702">			break;</span>
		case IMPROVING:
<span class="nc bnc" id="L704" title="All 2 branches missed.">			if (workImprovement == null) {</span>
<span class="nc" id="L705">				setWorkLeft(-1);</span>
<span class="nc" id="L706">			} else {</span>
<span class="nc" id="L707">				setWorkLeft(workImprovement.getTurnsToComplete()</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">						+ ((getMovesLeft() &gt; 0) ? 0 : 1));</span>
			}
<span class="nc" id="L710">			movesLeft = 0;</span>
<span class="nc" id="L711">			break;</span>
		case SKIPPED: // do nothing
<span class="nc" id="L713">			break;</span>
		default:
<span class="nc" id="L715">			setWorkLeft(-1);</span>
		}
<span class="nc" id="L717">		state = s;</span>
<span class="nc" id="L718">	}</span>

	/**
	 * Sets the given state to all the units that are carried.
	 *
	 * @param state
	 *            The &lt;code&gt;UnitState&lt;/code&gt; to set..
	 */
	public void setStateToAllChildren(UnitState state) {
<span class="nc bnc" id="L727" title="All 2 branches missed.">		if (canCarryUnits()) {</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">			for (Unit u : getUnitList())</span>
<span class="nc" id="L729">				u.setState(state);</span>
		}
<span class="nc" id="L731">	}</span>

	/**
	 * Change the owner of this unit.
	 *
	 * -vis: This routine calls setOwner() and thus has visibility implications.
	 * Ideally it should be in ServerUnit but we keep it here for the benefit of
	 * the test suite.
	 *
	 * @param owner
	 *            The new owner &lt;code&gt;Player&lt;/code&gt;.
	 */
	public void changeOwner(Player owner) {
<span class="nc" id="L744">		final Player oldOwner = this.owner;</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">		if (oldOwner == owner)</span>
<span class="nc" id="L746">			return;</span>

<span class="nc bnc" id="L748" title="All 2 branches missed.">		if (oldOwner == null) {</span>
<span class="nc" id="L749">			logger.warning(&quot;Unit &quot; + getId()</span>
<span class="nc" id="L750">					+ &quot; had no owner, when changing owner to &quot; + owner.getId());</span>
		}

		// This need to be set right away.
<span class="nc" id="L754">		setOwner(owner);</span>

		// Clear trade route and goto orders if changing owner.
<span class="nc bnc" id="L757" title="All 2 branches missed.">		if (getTradeRoute() != null)</span>
<span class="nc" id="L758">			setTradeRoute(null);</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">		if (getDestination() != null)</span>
<span class="nc" id="L760">			setDestination(null);</span>

		// If its a carrier, we need to update the units it has loaded
		// before finishing with it
<span class="nc bnc" id="L764" title="All 2 branches missed.">		for (Unit u : getUnitList())</span>
<span class="nc" id="L765">			u.changeOwner(owner);</span>

<span class="nc bnc" id="L767" title="All 4 branches missed.">		if (getTeacher() != null &amp;&amp; !canBeStudent(getTeacher())) {</span>
<span class="nc" id="L768">			getTeacher().setStudent(null);</span>
<span class="nc" id="L769">			setTeacher(null);</span>
		}

<span class="nc bnc" id="L772" title="All 2 branches missed.">		if (oldOwner != null)</span>
<span class="nc" id="L773">			oldOwner.removeUnit(this);</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">		if (owner != null)</span>
<span class="nc" id="L775">			owner.addUnit(this);</span>

<span class="nc" id="L777">		getGame().notifyOwnerChanged(this, oldOwner, owner);</span>
<span class="nc" id="L778">	}</span>

	/**
	 * Gets the unit role.
	 *
	 * @return The &lt;code&gt;Role&lt;/code&gt; of this &lt;code&gt;Unit&lt;/code&gt;.
	 */
	public Role getRole() {
<span class="nc" id="L786">		return role;</span>
	}

	/**
	 * Sets the &lt;code&gt;Role&lt;/code&gt; of this &lt;code&gt;Unit&lt;/code&gt;.
	 *
	 * @param role
	 *            The new &lt;code&gt;Role&lt;/code&gt;.
	 */
	public void setRole(Role role) {
<span class="nc" id="L796">		this.role = role;</span>
<span class="nc" id="L797">	}</span>

	/**
	 * Get the role count.
	 *
	 * @return The current role count.
	 */
	public int getRoleCount() {
<span class="nc" id="L805">		return roleCount;</span>
	}

	/**
	 * Set the role count.
	 *
	 * @param roleCount
	 *            The new role count.
	 */
	public void setRoleCount(int roleCount) {
<span class="nc" id="L815">		this.roleCount = roleCount;</span>
<span class="nc" id="L816">	}</span>

	/**
	 * Does this unit have the default role?
	 *
	 * @return True if the unit has the default &lt;code&gt;Role&lt;/code&gt;.
	 */
	public boolean hasDefaultRole() {
<span class="nc" id="L824">		return role.isDefaultRole();</span>
	}

	/**
	 * Get the last part of the role identifier, which is often used as part of
	 * a message key.
	 *
	 * @return The role suffix.
	 */
	public String getRoleSuffix() {
<span class="nc" id="L834">		return Role.getRoleSuffix(role.getId());</span>
	}

	/**
	 * Change the current role of this unit.
	 *
	 * @param role
	 *            The new &lt;code&gt;Role&lt;/code&gt;.
	 * @param roleCount
	 *            The new role count.
	 */
	public void changeRole(Role role, int roleCount) {
<span class="nc bnc" id="L846" title="All 2 branches missed.">		if (!role.isCompatibleWith(getRole())) {</span>
			// Clear experience if changing to an incompatible role.
<span class="nc" id="L848">			setExperience(0);</span>
		}
<span class="nc" id="L850">		setRole(role);</span>
<span class="nc bnc" id="L851" title="All 2 branches missed.">		setRoleCount((role.isDefaultRole()) ? 0 : roleCount);</span>
<span class="nc" id="L852">	}</span>

	/**
	 * Change the current role count. On zero, revert to default role.
	 *
	 * @param delta
	 *            The change to apply to the role count.
	 * @return True if the role count reached zero.
	 */
	public boolean changeRoleCount(int delta) {
<span class="nc" id="L862">		this.roleCount = Math.max(0, this.roleCount + delta);</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">		if (this.roleCount != 0)</span>
<span class="nc" id="L864">			return false;</span>
<span class="nc" id="L865">		this.role = getSpecification().getDefaultRole();</span>
<span class="nc" id="L866">		return true;</span>
	}

	/**
	 * Is a role available to this unit?
	 *
	 * @param role
	 *            The &lt;code&gt;Role&lt;/code&gt; to test.
	 * @return True if the role is available to this unit.
	 */
	public boolean roleIsAvailable(Role role) {
<span class="nc" id="L877">		return role.isAvailableTo(this);</span>
	}

	/**
	 * Filter a list of roles to return only those available to this unit.
	 *
	 * @param roles
	 *            The list of &lt;code&gt;Role&lt;/code&gt;s to filter, if null all
	 *            available roles are used.
	 * @return A list of available &lt;code&gt;Role&lt;/code&gt;s.
	 */
	public List&lt;Role&gt; getAvailableRoles(List&lt;Role&gt; roles) {
<span class="nc bnc" id="L889" title="All 2 branches missed.">		if (roles == null)</span>
<span class="nc" id="L890">			roles = getSpecification().getRoles();</span>
<span class="nc" id="L891">		return transform(roles, r -&gt; roleIsAvailable(r), Collectors.toList());</span>
	}

	/**
	 * Get a military role for this unit.
	 *
	 * @return A military &lt;code&gt;Role&lt;/code&gt;, or null if none found.
	 */
	public Role getMilitaryRole() {
<span class="nc" id="L900">		List&lt;Role&gt; roles = getAvailableRoles(getSpecification()</span>
<span class="nc" id="L901">				.getMilitaryRoles());</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">		return (roles.isEmpty()) ? null : roles.get(0);</span>
	}

	/**
	 * Get the change in goods required to change to a new role/count.
	 *
	 * @param role
	 *            The new &lt;code&gt;Role&lt;/code&gt; to change to.
	 * @param roleCount
	 *            The new role count.
	 * @return A list of &lt;code&gt;AbstractGoods&lt;/code&gt; defining the change in goods
	 *         required.
	 */
	public List&lt;AbstractGoods&gt; getGoodsDifference(Role role, int roleCount) {
<span class="nc" id="L916">		return Role.getGoodsDifference(getRole(), getRoleCount(), role,</span>
<span class="nc" id="L917">				roleCount);</span>
	}

	/**
	 * Sets the units location without updating any other variables
	 *
	 * get/setLocation are in Locatable interface.
	 *
	 * -vis: This routine changes player visibility.
	 *
	 * @param newLocation
	 *            The new &lt;code&gt;Location&lt;/code&gt;.
	 */
	public void setLocationNoUpdate(Location newLocation) {
<span class="nc" id="L931">		this.location = newLocation;</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">		if (newLocation instanceof Colony) {</span>
<span class="nc" id="L933">			logger.warning(&quot;Unit-&gt;Colony &quot;</span>
<span class="nc" id="L934">					+ this.getId()</span>
<span class="nc" id="L935">					+ &quot; &quot;</span>
<span class="nc" id="L936">					+ ((Colony) newLocation).getId()</span>
<span class="nc" id="L937">					+ &quot;\n&quot;</span>
<span class="nc" id="L938">					+ net.sf.freecol.common.debug.FreeColDebugger</span>
<span class="nc" id="L939">							.stackTraceToString());</span>
		}
<span class="nc" id="L941">	}</span>

	/**
	 * Verifies if the unit is aboard a carrier
	 *
	 * @return True if the unit is aboard a carrier.
	 */
	public boolean isOnCarrier() {
<span class="nc" id="L949">		return getLocation() instanceof Unit;</span>
	}

	/**
	 * Gets the carrier this unit is aboard if any.
	 *
	 * @return The carrier this unit is aboard, or null if none.
	 */
	public Unit getCarrier() {
<span class="nc bnc" id="L958" title="All 2 branches missed.">		return (isOnCarrier()) ? ((Unit) getLocation()) : null;</span>
	}

	/**
	 * Checks whether this &lt;code&gt;Unit&lt;/code&gt; is at sea off the map, or on board
	 * of a carrier that is.
	 *
	 * @return True if at sea.
	 */
	public boolean isAtSea() {
<span class="nc bnc" id="L968" title="All 2 branches missed.">		return (isOnCarrier()) ? getCarrier().isAtSea()</span>
<span class="nc" id="L969">				: getLocation() instanceof HighSeas;</span>
	}

	/**
	 * Checks if this unit is running a mission.
	 *
	 * @return True if this unit is running a mission.
	 */
	public boolean isInMission() {
<span class="nc bnc" id="L978" title="All 2 branches missed.">		return hasAbility(Ability.ESTABLISH_MISSION)</span>
<span class="nc bnc" id="L979" title="All 2 branches missed.">				&amp;&amp; (getLocation() instanceof IndianSettlement</span>
				// @compat 0.10.x
				// Remove this when PET missionary serialization is retired
<span class="nc bnc" id="L982" title="All 2 branches missed.">				|| getLocation() == null</span>
				// end @compat 0.10.x
				);
	}

	/**
	 * Checks whether this unit is working inside a colony.
	 *
	 * @return True if in colony.
	 */
	public boolean isInColony() {
<span class="nc" id="L993">		return getLocation() instanceof WorkLocation;</span>
	}

	/**
	 * Is this unit on a tile?
	 *
	 * @return True if this unit is on a tile.
	 */
	public boolean hasTile() {
<span class="nc bnc" id="L1002" title="All 2 branches missed.">		return getTile() != null;</span>
	}

	/**
	 * Gets the work location this unit is working in.
	 *
	 * @return The current &lt;code&gt;WorkLocation&lt;/code&gt;, or null if none.
	 */
	public WorkLocation getWorkLocation() {
<span class="nc bnc" id="L1011" title="All 2 branches missed.">		return (isInColony()) ? (WorkLocation) getLocation() : null;</span>
	}

	/**
	 * Gets the &lt;code&gt;Building&lt;/code&gt; this unit is working in.
	 *
	 * @return The current &lt;code&gt;Building&lt;/code&gt;, or null if none.
	 */
	public Building getWorkBuilding() {
<span class="nc bnc" id="L1020" title="All 2 branches missed.">		return (getLocation() instanceof Building) ? (Building) getLocation()</span>
<span class="nc" id="L1021">				: null;</span>
	}

	/**
	 * Gets the &lt;code&gt;ColonyTile&lt;/code&gt; this unit is working in.
	 *
	 * @return The current &lt;code&gt;ColonyTile&lt;/code&gt;, or null if none.
	 */
	public ColonyTile getWorkTile() {
<span class="nc bnc" id="L1030" title="All 2 branches missed.">		return (getLocation() instanceof ColonyTile) ? (ColonyTile) getLocation()</span>
<span class="nc" id="L1031">				: null;</span>
	}

	/**
	 * Gets the entry location for this unit to use when returning from
	 * {@link Europe}.
	 *
	 * @return The entry &lt;code&gt;Location&lt;/code&gt;.
	 */
	public Location getEntryLocation() {
<span class="nc bnc" id="L1041" title="All 2 branches missed.">		if (entryLocation == null) {</span>
<span class="nc" id="L1042">			entryLocation = owner.getEntryLocation();</span>
		}
<span class="nc" id="L1044">		return entryLocation;</span>
	}

	/**
	 * Sets the entry location in which this unit will be put when returning
	 * from {@link Europe}.
	 *
	 * @param entryLocation
	 *            The new entry &lt;code&gt;Location&lt;/code&gt;.
	 * @see #getEntryLocation
	 */
	public void setEntryLocation(Location entryLocation) {
<span class="nc" id="L1056">		this.entryLocation = entryLocation;</span>
<span class="nc bnc" id="L1057" title="All 2 branches missed.">		if (entryLocation != null) {</span>
<span class="nc" id="L1058">			owner.setEntryLocation(entryLocation);</span>
		}
<span class="nc" id="L1060">	}</span>

	/**
	 * Gets the entry tile for this unit, or if null the default entry location
	 * for the owning player.
	 *
	 * @return The entry &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public Tile getFullEntryLocation() {
<span class="nc bnc" id="L1069" title="All 2 branches missed.">		return (entryLocation != null) ? (Tile) entryLocation : (owner</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">				.getEntryLocation() == null) ? null : owner.getEntryLocation()</span>
<span class="nc" id="L1071">				.getTile();</span>
	}

	/**
	 * Get the moves left this turn.
	 *
	 * @return The number of moves this &lt;code&gt;Unit&lt;/code&gt; has left.
	 */
	@Override
	public int getMovesLeft() {
<span class="nc" id="L1081">		return movesLeft;</span>
	}

	/**
	 * Sets the moves left this turn.
	 *
	 * @param moves
	 *            The new amount of moves left this &lt;code&gt;Unit&lt;/code&gt; should
	 *            have.
	 */
	public void setMovesLeft(int moves) {
<span class="nc bnc" id="L1092" title="All 2 branches missed.">		this.movesLeft = (moves &lt; 0) ? 0 : moves;</span>
<span class="nc" id="L1093">	}</span>

	/**
	 * Gets the type of goods this unit is producing in its current occupation.
	 *
	 * @return The type of goods this unit is producing.
	 */
	public GoodsType getWorkType() {
<span class="nc" id="L1101">		return workType;</span>
	}

	/**
	 * Set the type of goods this unit is producing in its current occupation.
	 *
	 * @param type
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
	 */
	public void setWorkType(GoodsType type) {
<span class="nc" id="L1111">		this.workType = type;</span>
<span class="nc" id="L1112">	}</span>

	/**
	 * Change the type of goods this unit is producing in its current
	 * occupation. Updates the work location production and the unit experience
	 * type if necessary.
	 *
	 * @param type
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
	 */
	public void changeWorkType(GoodsType type) {
<span class="nc" id="L1123">		setWorkType(type);</span>
<span class="nc bnc" id="L1124" title="All 2 branches missed.">		if (type != null)</span>
<span class="nc" id="L1125">			experienceType = type;</span>
<span class="nc" id="L1126">		WorkLocation wl = getWorkLocation();</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">		if (wl != null)</span>
<span class="nc" id="L1128">			wl.updateProductionType();</span>
<span class="nc" id="L1129">	}</span>

	/**
	 * Gets the type of goods this unit has accrued experience producing.
	 *
	 * @return The type of goods this unit would produce.
	 */
	public GoodsType getExperienceType() {
<span class="nc" id="L1137">		return experienceType;</span>
	}

	/**
	 * Gets the experience of this &lt;code&gt;Unit&lt;/code&gt; at its current
	 * experienceType.
	 *
	 * @return The experience of this &lt;code&gt;Unit&lt;/code&gt; at its current
	 *         experienceType.
	 * @see #modifyExperience
	 */
	public int getExperience() {
<span class="nc" id="L1149">		return experience;</span>
	}

	/**
	 * Sets the experience of this &lt;code&gt;Unit&lt;/code&gt; at its current
	 * experienceType.
	 *
	 * @param experience
	 *            The new experience of this &lt;code&gt;Unit&lt;/code&gt; at its current
	 *            experienceType.
	 * @see #modifyExperience
	 */
	public void setExperience(int experience) {
<span class="nc" id="L1162">		this.experience = Math</span>
<span class="nc" id="L1163">				.min(experience, getType().getMaximumExperience());</span>
<span class="nc" id="L1164">	}</span>

	/**
	 * Modifies the experience of this &lt;code&gt;Unit&lt;/code&gt; at its current
	 * experienceType.
	 *
	 * @param value
	 *            The value by which to modify the experience of this
	 *            &lt;code&gt;Unit&lt;/code&gt;.
	 * @see #getExperience
	 */
	public void modifyExperience(int value) {
<span class="nc" id="L1176">		experience += value;</span>
<span class="nc" id="L1177">	}</span>

	/**
	 * Gets the amount of work left.
	 *
	 * @return The amount of work left.
	 */
	public int getWorkLeft() {
<span class="nc" id="L1185">		return workLeft;</span>
	}

	/**
	 * Sets the amount of work left.
	 *
	 * @param workLeft
	 *            The new amount of work left.
	 */
	public void setWorkLeft(int workLeft) {
<span class="nc" id="L1195">		this.workLeft = workLeft;</span>
<span class="nc" id="L1196">	}</span>

	/**
	 * Get the number of turns of work left.
	 *
	 * @return The number of turns of work left.
	 */
	public int getWorkTurnsLeft() {
<span class="nc bnc" id="L1204" title="All 2 branches missed.">		return (state == UnitState.IMPROVING &amp;&amp; unitType</span>
<span class="nc bnc" id="L1205" title="All 2 branches missed.">				.hasAbility(Ability.EXPERT_PIONEER)) ? (getWorkLeft() + 1) / 2</span>
<span class="nc" id="L1206">				: getWorkLeft();</span>
	}

	/**
	 * Gets the TileImprovement that this pioneer is contributing to.
	 *
	 * @return The &lt;code&gt;TileImprovement&lt;/code&gt; the pioneer is working on.
	 */
	public TileImprovement getWorkImprovement() {
<span class="nc" id="L1215">		return workImprovement;</span>
	}

	/**
	 * Sets the TileImprovement that this pioneer is contributing to.
	 *
	 * @param imp
	 *            The new &lt;code&gt;TileImprovement&lt;/code&gt; the pioneer is to work
	 *            on.
	 */
	public void setWorkImprovement(TileImprovement imp) {
<span class="nc" id="L1226">		workImprovement = imp;</span>
<span class="nc" id="L1227">	}</span>

	/**
	 * Get the unit being taught.
	 *
	 * @return A student &lt;code&gt;Unit&lt;/code&gt; if any.
	 */
	public final Unit getStudent() {
<span class="nc" id="L1235">		return student;</span>
	}

	/**
	 * Set the student unit.
	 *
	 * @param newStudent
	 *            The new student &lt;code&gt;Unit&lt;/code&gt;.
	 */
	public final void setStudent(final Unit newStudent) {
<span class="nc" id="L1245">		Unit oldStudent = this.student;</span>
<span class="nc bnc" id="L1246" title="All 2 branches missed.">		if (oldStudent == newStudent)</span>
<span class="nc" id="L1247">			return;</span>

<span class="nc bnc" id="L1249" title="All 2 branches missed.">		if (newStudent == null) {</span>
<span class="nc" id="L1250">			this.student = null;</span>
<span class="nc bnc" id="L1251" title="All 4 branches missed.">			if (oldStudent != null &amp;&amp; oldStudent.getTeacher() == this) {</span>
<span class="nc" id="L1252">				oldStudent.setTeacher(null);</span>
			}
<span class="nc bnc" id="L1254" title="All 2 branches missed.">		} else if (newStudent.getColony() != null</span>
<span class="nc bnc" id="L1255" title="All 2 branches missed.">				&amp;&amp; newStudent.getColony() == getColony()</span>
<span class="nc bnc" id="L1256" title="All 2 branches missed.">				&amp;&amp; newStudent.canBeStudent(this)) {</span>
<span class="nc bnc" id="L1257" title="All 4 branches missed.">			if (oldStudent != null &amp;&amp; oldStudent.getTeacher() == this) {</span>
<span class="nc" id="L1258">				oldStudent.setTeacher(null);</span>
			}
<span class="nc" id="L1260">			this.student = newStudent;</span>
<span class="nc" id="L1261">			newStudent.setTeacher(this);</span>
<span class="nc" id="L1262">		} else {</span>
<span class="nc" id="L1263">			throw new IllegalStateException(&quot;Unit can not be student: &quot;</span>
<span class="nc" id="L1264">					+ newStudent);</span>
		}
<span class="nc" id="L1266">	}</span>

	/**
	 * Get the unit teaching this one.
	 *
	 * @return A teacher &lt;code&gt;Unit&lt;/code&gt;.
	 */
	public final Unit getTeacher() {
<span class="nc" id="L1274">		return teacher;</span>
	}

	/**
	 * Set the teacher for this unit.
	 *
	 * @param newTeacher
	 *            The new teacher &lt;code&gt;Unit&lt;/code&gt;.
	 */
	public final void setTeacher(final Unit newTeacher) {
<span class="nc" id="L1284">		Unit oldTeacher = this.teacher;</span>
<span class="nc bnc" id="L1285" title="All 2 branches missed.">		if (newTeacher == oldTeacher)</span>
<span class="nc" id="L1286">			return;</span>

<span class="nc bnc" id="L1288" title="All 2 branches missed.">		if (newTeacher == null) {</span>
<span class="nc" id="L1289">			this.teacher = null;</span>
<span class="nc bnc" id="L1290" title="All 4 branches missed.">			if (oldTeacher != null &amp;&amp; oldTeacher.getStudent() == this) {</span>
<span class="nc" id="L1291">				oldTeacher.setStudent(null);</span>
			}
<span class="nc" id="L1293">		} else {</span>
<span class="nc" id="L1294">			UnitType skillTaught = newTeacher.getType().getSkillTaught();</span>
<span class="nc bnc" id="L1295" title="All 2 branches missed.">			if (newTeacher.getColony() != null</span>
<span class="nc bnc" id="L1296" title="All 2 branches missed.">					&amp;&amp; newTeacher.getColony() == getColony()</span>
<span class="nc bnc" id="L1297" title="All 2 branches missed.">					&amp;&amp; getColony().canTrain(skillTaught)) {</span>
<span class="nc bnc" id="L1298" title="All 4 branches missed.">				if (oldTeacher != null &amp;&amp; oldTeacher.getStudent() == this) {</span>
<span class="nc" id="L1299">					oldTeacher.setStudent(null);</span>
				}
<span class="nc" id="L1301">				this.teacher = newTeacher;</span>
<span class="nc" id="L1302">				this.teacher.setStudent(this);</span>
<span class="nc" id="L1303">			} else {</span>
<span class="nc" id="L1304">				throw new IllegalStateException(&quot;Unit can not be teacher: &quot;</span>
<span class="nc" id="L1305">						+ newTeacher);</span>
			}
		}
<span class="nc" id="L1308">	}</span>

	/**
	 * Gets the number of turns this unit has been training.
	 *
	 * @return The number of turns of training this &lt;code&gt;Unit&lt;/code&gt; has given.
	 * @see #setTurnsOfTraining
	 * @see #getNeededTurnsOfTraining
	 */
	public int getTurnsOfTraining() {
<span class="nc" id="L1318">		return turnsOfTraining;</span>
	}

	/**
	 * Sets the number of turns this unit has been training.
	 *
	 * @param turnsOfTraining
	 *            The number of turns of training this &lt;code&gt;Unit&lt;/code&gt; has
	 *            given.
	 * @see #getNeededTurnsOfTraining
	 */
	public void setTurnsOfTraining(int turnsOfTraining) {
<span class="nc" id="L1330">		this.turnsOfTraining = turnsOfTraining;</span>
<span class="nc" id="L1331">	}</span>

	/**
	 * Gets the number of turns this unit has to train to educate a student.
	 * This value is only meaningful for units that can be put in a school.
	 *
	 * @return The turns of training needed to teach its current type to a free
	 *         colonist or to promote an indentured servant or a petty criminal.
	 * @see #getTurnsOfTraining
	 */
	public int getNeededTurnsOfTraining() {
		// number of turns is 4/6/8 for skill 1/2/3
<span class="nc" id="L1343">		int result = 0;</span>
<span class="nc bnc" id="L1344" title="All 2 branches missed.">		if (student != null) {</span>
<span class="nc" id="L1345">			result = getNeededTurnsOfTraining(unitType, student.unitType);</span>
<span class="nc bnc" id="L1346" title="All 2 branches missed.">			if (getColony() != null) {</span>
<span class="nc" id="L1347">				result -= getColony().getProductionBonus();</span>
			}
		}
<span class="nc" id="L1350">		return result;</span>
	}

	/**
	 * Gets the number of turns this unit has to train to educate a student.
	 * This value is only meaningful for units that can be put in a school.
	 *
	 * @param typeTeacher
	 *            The teacher &lt;code&gt;UnitType&lt;/code&gt;.
	 * @param typeStudent
	 *            the student &lt;code&gt;UnitType&lt;/code&gt;.
	 * @return The turns of training needed to teach its current type to a free
	 *         colonist or to promote an indentured servant or a petty criminal.
	 * @see #getTurnsOfTraining
	 */
	public int getNeededTurnsOfTraining(UnitType typeTeacher,
			UnitType typeStudent) {
<span class="nc" id="L1367">		UnitType teaching = getUnitTypeTeaching(typeTeacher, typeStudent);</span>
<span class="nc bnc" id="L1368" title="All 2 branches missed.">		if (teaching != null) {</span>
<span class="nc" id="L1369">			return typeStudent.getEducationTurns(teaching);</span>
		} else {
<span class="nc" id="L1371">			throw new IllegalStateException(&quot;typeTeacher=&quot; + typeTeacher</span>
<span class="nc" id="L1372">					+ &quot; typeStudent=&quot; + typeStudent);</span>
		}
	}

	/**
	 * Gets the UnitType which a teacher is teaching to a student. This value is
	 * only meaningful for teachers that can be put in a school.
	 *
	 * @param typeTeacher
	 *            The teacher &lt;code&gt;UnitType&lt;/code&gt;.
	 * @param typeStudent
	 *            The student &lt;code&gt;UnitType&lt;/code&gt;.
	 * @return The &lt;code&gt;UnitType&lt;/code&gt; taught.
	 * @see #getTurnsOfTraining
	 *
	 */
	public static UnitType getUnitTypeTeaching(UnitType typeTeacher,
			UnitType typeStudent) {
<span class="nc" id="L1390">		UnitType skillTaught = typeTeacher.getSkillTaught();</span>
<span class="nc bnc" id="L1391" title="All 2 branches missed.">		if (typeStudent.canBeUpgraded(skillTaught, ChangeType.EDUCATION)) {</span>
<span class="nc" id="L1392">			return skillTaught;</span>
		} else {
<span class="nc" id="L1394">			return typeStudent.getEducationUnit(0);</span>
		}
	}

	/**
	 * Can this unit be a student?
	 *
	 * @param teacher
	 *            The teacher &lt;code&gt;Unit&lt;/code&gt; which is trying to teach it.
	 * @return True if the unit can be taught by the teacher.
	 */
	public boolean canBeStudent(Unit teacher) {
<span class="nc bnc" id="L1406" title="All 4 branches missed.">		return teacher != this &amp;&amp; canBeStudent(unitType, teacher.unitType);</span>
	}

	/**
	 * Can a unit be a student?
	 *
	 * @param typeStudent
	 *            The student &lt;code&gt;UnitType&lt;/code&gt;.
	 * @param typeTeacher
	 *            The teacher &lt;code&gt;UnitType&lt;/code&gt;.
	 * @return True if the student can be taught by the teacher.
	 */
	public boolean canBeStudent(UnitType typeStudent, UnitType typeTeacher) {
<span class="nc bnc" id="L1419" title="All 2 branches missed.">		return getUnitTypeTeaching(typeTeacher, typeStudent) != null;</span>
	}

	/**
	 * Gets the nationality of this Unit.
	 *
	 * Nationality represents a Unit's personal allegiance to a nation. This may
	 * conflict with who currently issues orders to the Unit (the owner).
	 *
	 * @return The nationality of this Unit.
	 */
	public String getNationality() {
<span class="nc" id="L1431">		return nationality;</span>
	}

	/**
	 * Sets the nationality of this Unit. A unit will change nationality when it
	 * switches owners willingly. Currently only Converts do this, but it opens
	 * the possibility of naturalisation.
	 *
	 * @param newNationality
	 *            The new nationality of this Unit.
	 */
	public void setNationality(String newNationality) {
<span class="nc bnc" id="L1443" title="All 2 branches missed.">		if (isPerson()) {</span>
<span class="nc" id="L1444">			nationality = newNationality;</span>
<span class="nc" id="L1445">		} else {</span>
<span class="nc" id="L1446">			throw new UnsupportedOperationException(</span>
<span class="nc" id="L1447">					&quot;Can not set the nationality of a Unit which is not a person!&quot;);</span>
		}
<span class="nc" id="L1449">	}</span>

	/**
	 * Gets the ethnicity of this Unit.
	 *
	 * Ethnicity is inherited from the inhabitants of the place where the Unit
	 * was born. Allows former converts to become native-looking colonists.
	 *
	 * @return The ethnicity of this Unit.
	 */
	public String getEthnicity() {
<span class="nc" id="L1460">		return ethnicity;</span>
	}

	/**
	 * Sets the ethnicity of this Unit.
	 *
	 * @param newEthnicity
	 *            The new ethnicity of this Unit.
	 */
	public void setEthnicity(String newEthnicity) {
<span class="nc" id="L1470">		this.ethnicity = newEthnicity;</span>
<span class="nc" id="L1471">	}</span>

	/**
	 * Identifies whether this unit came from a native tribe.
	 *
	 * @return Whether this unit looks native or not.
	 */
	public boolean hasNativeEthnicity() {
		try {
			// FIXME: getNation() could fail, but getNationType()
			// doesn't work as expected
<span class="nc" id="L1482">			return getGame().getSpecification().getNation(ethnicity).getType()</span>
<span class="nc" id="L1483">					.isIndian();</span>
<span class="nc" id="L1484">		} catch (Exception e) {</span>
<span class="nc" id="L1485">			return false;</span>
		}
	}

	/**
	 * Gets the &lt;code&gt;IndianSettlement&lt;/code&gt; home for this unit.
	 *
	 * @return The home &lt;code&gt;IndianSettlement&lt;/code&gt; of this unit.
	 */
	public IndianSettlement getHomeIndianSettlement() {
<span class="nc" id="L1495">		return indianSettlement;</span>
	}

	/**
	 * Sets the home &lt;code&gt;IndianSettlement&lt;/code&gt; for this unit.
	 *
	 * @param indianSettlement
	 *            The &lt;code&gt;IndianSettlement&lt;/code&gt; that should now own this
	 *            &lt;code&gt;Unit&lt;/code&gt;.
	 */
	public void setHomeIndianSettlement(IndianSettlement indianSettlement) {
<span class="nc bnc" id="L1506" title="All 2 branches missed.">		if (this.indianSettlement != null) {</span>
<span class="nc" id="L1507">			this.indianSettlement.removeOwnedUnit(this);</span>
		}

<span class="nc" id="L1510">		this.indianSettlement = indianSettlement;</span>

<span class="nc bnc" id="L1512" title="All 2 branches missed.">		if (indianSettlement != null) {</span>
<span class="nc" id="L1513">			indianSettlement.addOwnedUnit(this);</span>
		}
<span class="nc" id="L1515">	}</span>

	/**
	 * Gets the unit hit points.
	 *
	 * This is currently only used for damaged ships, but might get an extended
	 * use later.
	 *
	 * @return The hit points this &lt;code&gt;Unit&lt;/code&gt; has.
	 * @see UnitType#getHitPoints
	 */
	public int getHitPoints() {
<span class="nc" id="L1527">		return hitPoints;</span>
	}

	/**
	 * Sets the hit points for this unit.
	 *
	 * @param hitPoints
	 *            The new hit points for this unit.
	 */
	public void setHitPoints(int hitPoints) {
<span class="nc" id="L1537">		this.hitPoints = hitPoints;</span>
<span class="nc" id="L1538">	}</span>

	/**
	 * Checks if this unit is under repair.
	 *
	 * @return True if under repair.
	 */
	public boolean isDamaged() {
<span class="nc bnc" id="L1546" title="All 2 branches missed.">		return hitPoints &lt; unitType.getHitPoints();</span>
	}

	/**
	 * Get how many turns left to be repaired
	 *
	 * @return The number of turns left to be repaired.
	 */
	public int getTurnsForRepair() {
<span class="nc" id="L1555">		return unitType.getHitPoints() - getHitPoints();</span>
	}

	/**
	 * Get the destination of this unit.
	 *
	 * @return The destination &lt;code&gt;Location&lt;/code&gt; of this &lt;code&gt;Unit&lt;/code&gt;.
	 */
	public Location getDestination() {
<span class="nc" id="L1564">		return destination;</span>
	}

	/**
	 * Sets the destination of this unit.
	 *
	 * @param newDestination
	 *            The new destination &lt;code&gt;Location&lt;/code&gt;.
	 */
	public void setDestination(Location newDestination) {
<span class="nc" id="L1574">		this.destination = newDestination;</span>
<span class="nc" id="L1575">	}</span>

	/**
	 * Get the unit trade route, if any.
	 *
	 * @return The &lt;code&gt;TradeRoute&lt;/code&gt;, or null if none.
	 */
	public final TradeRoute getTradeRoute() {
<span class="nc" id="L1583">		return tradeRoute;</span>
	}

	/**
	 * Set the unit trade route.
	 *
	 * @param newTradeRoute
	 *            The new &lt;code&gt;TradeRoute&lt;/code&gt; value.
	 */
	public final void setTradeRoute(final TradeRoute newTradeRoute) {
<span class="nc" id="L1593">		this.tradeRoute = newTradeRoute;</span>
<span class="nc" id="L1594">	}</span>

	/**
	 * Get the stop the unit is heading for or at.
	 *
	 * @return The target &lt;code&gt;Stop&lt;/code&gt;.
	 */
	public TradeRouteStop getStop() {
<span class="nc bnc" id="L1602" title="All 2 branches missed.">		return (validateCurrentStop() &lt; 0) ? null : getTradeRoute().getStops()</span>
<span class="nc" id="L1603">				.get(currentStop);</span>
	}

	/**
	 * Get the stop the unit is heading for or at.
	 *
	 * @return The target &lt;code&gt;Stop&lt;/code&gt;.
	 */
	public List&lt;TradeRouteStop&gt; getCurrentStops() {
<span class="nc bnc" id="L1612" title="All 2 branches missed.">		if (validateCurrentStop() &lt; 0)</span>
<span class="nc" id="L1613">			return null;</span>
<span class="nc" id="L1614">		List&lt;TradeRouteStop&gt; stops = new ArrayList&lt;TradeRouteStop&gt;(</span>
<span class="nc" id="L1615">				getTradeRoute().getStops());</span>
<span class="nc" id="L1616">		rotate(stops, currentStop);</span>
<span class="nc" id="L1617">		return stops;</span>
	}

	/**
	 * Get the current trade route stop.
	 *
	 * @return The current stop index.
	 */
	public int getCurrentStop() {
<span class="nc" id="L1626">		return currentStop;</span>
	}

	/**
	 * Set the current stop.
	 *
	 * @param currentStop
	 *            A new value for the currentStop.
	 */
	public void setCurrentStop(int currentStop) {
<span class="nc" id="L1636">		this.currentStop = currentStop;</span>
<span class="nc" id="L1637">	}</span>

	/**
	 * Validate and return the current stop.
	 *
	 * @return The current stop index, or negative on failure.
	 */
	public int validateCurrentStop() {
<span class="nc bnc" id="L1645" title="All 2 branches missed.">		if (tradeRoute == null) {</span>
<span class="nc" id="L1646">			currentStop = -1;</span>
<span class="nc" id="L1647">		} else {</span>
<span class="nc" id="L1648">			List&lt;TradeRouteStop&gt; stops = tradeRoute.getStops();</span>
<span class="nc bnc" id="L1649" title="All 4 branches missed.">			if (stops == null || stops.isEmpty()) {</span>
<span class="nc" id="L1650">				currentStop = -1;</span>
<span class="nc" id="L1651">			} else {</span>
<span class="nc bnc" id="L1652" title="All 4 branches missed.">				if (currentStop &lt; 0 || currentStop &gt;= stops.size()) {</span>
					// The current stop can become out of range if the trade
					// route is modified.
<span class="nc" id="L1655">					currentStop = 0;</span>
				}
			}
		}
<span class="nc" id="L1659">		return currentStop;</span>
	}

	/**
	 * Convenience function to check if a unit is at a stop.
	 *
	 * @param stop
	 *            The &lt;code&gt;TradeRouteStop&lt;/code&gt; to check.
	 * @return True if the unit is at the given stop.
	 */
	public boolean atStop(TradeRouteStop stop) {
<span class="nc" id="L1670">		return Map.isSameLocation(getLocation(), stop.getLocation());</span>
	}

	/**
	 * Get the current trade location.
	 *
	 * @return The &lt;code&gt;TradeLocation&lt;/code&gt; for this unit.
	 */
	public TradeLocation getTradeLocation() {
		Colony colony;
		IndianSettlement is;
<span class="nc bnc" id="L1681" title="All 2 branches missed.">		return ((colony = getColony()) != null) ? colony</span>
<span class="nc bnc" id="L1682" title="All 2 branches missed.">				: ((is = getIndianSettlement()) != null) ? is</span>
<span class="nc bnc" id="L1683" title="All 2 branches missed.">						: (isInEurope()) ? (TradeLocation) getOwner()</span>
<span class="nc" id="L1684">								.getEurope() : null;</span>
	}

	/**
	 * Get the current amount of treasure in this unit.
	 *
	 * @return The amount of treasure.
	 * @exception IllegalStateException
	 *                if this is not a treasure carrying unit.
	 */
	public int getTreasureAmount() {
<span class="nc bnc" id="L1695" title="All 2 branches missed.">		if (!canCarryTreasure()) {</span>
<span class="nc" id="L1696">			throw new IllegalStateException(&quot;Unit can not carry treasure&quot;);</span>
		}
<span class="nc" id="L1698">		return treasureAmount;</span>
	}

	/**
	 * Set the amount of treasure in this unit.
	 *
	 * @param amount
	 *            The new amount of treasure.
	 */
	public void setTreasureAmount(int amount) {
<span class="nc bnc" id="L1708" title="All 2 branches missed.">		if (!canCarryTreasure()) {</span>
<span class="nc" id="L1709">			throw new IllegalStateException(&quot;Unit can not carry treasure&quot;);</span>
		}
<span class="nc" id="L1711">		this.treasureAmount = amount;</span>
<span class="nc" id="L1712">	}</span>

	/**
	 * Gets the attrition of this unit.
	 *
	 * @return The attrition of this unit.
	 */
	public int getAttrition() {
<span class="nc" id="L1720">		return attrition;</span>
	}

	/**
	 * Sets the attrition of this unit.
	 *
	 * @param attrition
	 *            The new attrition of this unit.
	 */
	public void setAttrition(int attrition) {
<span class="nc" id="L1730">		this.attrition = attrition;</span>
<span class="nc" id="L1731">	}</span>

	/**
	 * Get the visible amount of goods that is carried by this unit.
	 *
	 * @return The visible amount of goods carried by this &lt;code&gt;Unit&lt;/code&gt;.
	 */
	public int getVisibleGoodsCount() {
<span class="nc bnc" id="L1739" title="All 2 branches missed.">		return (visibleGoodsCount &gt;= 0) ? visibleGoodsCount</span>
<span class="nc" id="L1740">				: getGoodsSpaceTaken();</span>
	}

	// Combat routines

	/**
	 * Gets a role that can be equipped automatically assumed in case of an
	 * attack.
	 *
	 * Paul Revere makes an unarmed colonist in a settlement pick up a
	 * stock-piled musket if attacked, so the bonus should be applied for
	 * unarmed colonists inside colonies where there are muskets available.
	 * Natives can also auto-arm.
	 *
	 * @return A &lt;code&gt;Role&lt;/code&gt; that can be automatically assumed by this
	 *         unit, or null if none.
	 */
	public Role getAutomaticRole() {
<span class="nc bnc" id="L1758" title="All 2 branches missed.">		if (!hasDefaultRole())</span>
<span class="nc" id="L1759">			return null;</span>
<span class="nc" id="L1760">		Set&lt;Ability&gt; autoDefence = getAbilities(Ability.AUTOMATIC_EQUIPMENT);</span>
<span class="nc bnc" id="L1761" title="All 2 branches missed.">		if (autoDefence.isEmpty())</span>
<span class="nc" id="L1762">			return null;</span>
<span class="nc bnc" id="L1763" title="All 2 branches missed.">		Settlement settlement = (isInColony()) ? getColony()</span>
<span class="nc bnc" id="L1764" title="All 2 branches missed.">				: (getLocation() instanceof IndianSettlement) ? (Settlement) getLocation()</span>
<span class="nc" id="L1765">						: null;</span>
<span class="nc bnc" id="L1766" title="All 2 branches missed.">		if (settlement == null)</span>
<span class="nc" id="L1767">			return null;</span>

<span class="nc" id="L1769">		final Specification spec = getSpecification();</span>
<span class="nc bnc" id="L1770" title="All 2 branches missed.">		for (Ability ability : autoDefence) {</span>
<span class="nc bnc" id="L1771" title="All 2 branches missed.">			for (Scope scope : ability.getScopes()) {</span>
<span class="nc" id="L1772">				Role role = spec.getRole(scope.getType());</span>
<span class="nc bnc" id="L1773" title="All 2 branches missed.">				if (role != null</span>
<span class="nc" id="L1774">						&amp;&amp; settlement</span>
<span class="nc bnc" id="L1775" title="All 2 branches missed.">								.containsGoods(getGoodsDifference(role, 1))) {</span>
<span class="nc" id="L1776">					return role;</span>
				}
			}
		}
<span class="nc" id="L1780">		return null;</span>
	}

	/**
	 * After winning a battle, can this unit capture the loser's role equipment?
	 *
	 * @param role
	 *            The loser unit &lt;code&gt;Role&lt;/code&gt;.
	 * @return The &lt;code&gt;Role&lt;/code&gt; available to this unit as a result of
	 *         capturing the loser equipment.
	 */
	public Role canCaptureEquipment(Role role) {
<span class="nc bnc" id="L1792" title="All 2 branches missed.">		if (!hasAbility(Ability.CAPTURE_EQUIPMENT))</span>
<span class="nc" id="L1793">			return null;</span>
<span class="nc" id="L1794">		final Specification spec = getSpecification();</span>
<span class="nc" id="L1795">		final Role oldRole = getRole();</span>
<span class="nc bnc" id="L1796" title="All 2 branches missed.">		for (Role r : getAvailableRoles(spec.getMilitaryRoles())) {</span>
<span class="nc bnc" id="L1797" title="All 2 branches missed.">			for (Role.RoleChange rc : r.getRoleChanges()) {</span>
<span class="nc bnc" id="L1798" title="All 4 branches missed.">				if (rc.getFrom(spec) == oldRole &amp;&amp; rc.getCapture(spec) == role)</span>
<span class="nc" id="L1799">					return r;</span>
			}
		}
<span class="nc" id="L1802">		return null;</span>
	}

	/**
	 * Does losing a piece of equipment mean the death of this unit?
	 *
	 * @return True if the unit is doomed.
	 */
	public boolean losingEquipmentKillsUnit() {
<span class="nc bnc" id="L1811" title="All 2 branches missed.">		return hasAbility(Ability.DISPOSE_ON_ALL_EQUIPMENT_LOST)</span>
<span class="nc bnc" id="L1812" title="All 2 branches missed.">				&amp;&amp; getRole().getDowngrade() == null;</span>
	}

	/**
	 * Does losing equipment mean the demotion of this unit?
	 *
	 * @return True if the unit is to be demoted.
	 */
	public boolean losingEquipmentDemotesUnit() {
<span class="nc bnc" id="L1821" title="All 2 branches missed.">		return hasAbility(Ability.DEMOTE_ON_ALL_EQUIPMENT_LOST)</span>
<span class="nc bnc" id="L1822" title="All 2 branches missed.">				&amp;&amp; getRole().getDowngrade() == null;</span>
	}

	/**
	 * Does the unit have arms?
	 *
	 * @return True if the unit has arms.
	 */
	public boolean isArmed() {
<span class="nc" id="L1831">		return hasAbility(Ability.ARMED);</span>
	}

	/**
	 * Does the unit have a mount?
	 *
	 * @return True if the unit have a mount.
	 */
	public boolean isMounted() {
<span class="nc" id="L1840">		return hasAbility(Ability.MOUNTED);</span>
	}

	/**
	 * Is the unit a beached ship?
	 *
	 * @return True if the unit is a beached ship.
	 */
	public boolean isBeached() {
<span class="nc" id="L1849">		return isBeached(getTile());</span>
	}

	/**
	 * Would this unit be beached if it was on a particular tile?
	 *
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to check.
	 * @return True if the unit is a beached ship.
	 */
	public boolean isBeached(Tile tile) {
<span class="nc bnc" id="L1860" title="All 6 branches missed.">		return isNaval() &amp;&amp; tile != null &amp;&amp; tile.isLand()</span>
<span class="nc bnc" id="L1861" title="All 2 branches missed.">				&amp;&amp; !tile.hasSettlement();</span>
	}

	/**
	 * Checks if this is an defensive unit. That is: a unit which can be used to
	 * defend a &lt;code&gt;Settlement&lt;/code&gt;.
	 *
	 * Note! As this method is used by the AI it really means that the unit can
	 * defend as is. To be specific an unarmed colonist is not defensive yet,
	 * even if Paul Revere and stockpiled muskets are available. That check is
	 * only performed on an actual attack.
	 *
	 * A settlement is lost when there are no more defensive units.
	 *
	 * @return True if this is a defensive unit meaning it can be used to defend
	 *         a &lt;code&gt;Colony&lt;/code&gt;. This would normally mean that a defensive
	 *         unit also will be offensive.
	 */
	public boolean isDefensiveUnit() {
<span class="nc bnc" id="L1880" title="All 4 branches missed.">		return (unitType.isDefensive() || getRole().isDefensive())</span>
<span class="nc bnc" id="L1881" title="All 2 branches missed.">				&amp;&amp; !isCarrier(); // Not wagons or ships</span>
	}

	/**
	 * Checks if this is an offensive unit. That is, one that can attack other
	 * units.
	 *
	 * @return True if this is an offensive unit.
	 */
	public boolean isOffensiveUnit() {
<span class="nc bnc" id="L1891" title="All 4 branches missed.">		return unitType.isOffensive() || getRole().isOffensive();</span>
	}

	/**
	 * Is an alternate unit a better defender than the current choice. Prefer if
	 * there is no current defender, or if the alternate unit is better armed,
	 * or provides greater defensive power and does not replace a defensive unit
	 * defender with a non-defensive unit.
	 *
	 * @param defender
	 *            The current defender &lt;code&gt;Unit&lt;/code&gt;.
	 * @param defenderPower
	 *            Its defence power.
	 * @param other
	 *            An alternate &lt;code&gt;Unit&lt;/code&gt;.
	 * @param otherPower
	 *            Its defence power.
	 * @return True if the other unit should be preferred.
	 */
	public static boolean betterDefender(Unit defender, double defenderPower,
			Unit other, double otherPower) {
<span class="nc bnc" id="L1912" title="All 2 branches missed.">		if (defender == null) {</span>
<span class="nc" id="L1913">			return true;</span>
<span class="nc bnc" id="L1914" title="All 4 branches missed.">		} else if (defender.isPerson() &amp;&amp; other.isPerson()</span>
<span class="nc bnc" id="L1915" title="All 4 branches missed.">				&amp;&amp; !defender.isArmed() &amp;&amp; other.isArmed()) {</span>
<span class="nc" id="L1916">			return true;</span>
<span class="nc bnc" id="L1917" title="All 4 branches missed.">		} else if (defender.isPerson() &amp;&amp; other.isPerson()</span>
<span class="nc bnc" id="L1918" title="All 4 branches missed.">				&amp;&amp; defender.isArmed() &amp;&amp; !other.isArmed()) {</span>
<span class="nc" id="L1919">			return false;</span>
<span class="nc bnc" id="L1920" title="All 4 branches missed.">		} else if (!defender.isDefensiveUnit() &amp;&amp; other.isDefensiveUnit()) {</span>
<span class="nc" id="L1921">			return true;</span>
<span class="nc bnc" id="L1922" title="All 4 branches missed.">		} else if (defender.isDefensiveUnit() &amp;&amp; !other.isDefensiveUnit()) {</span>
<span class="nc" id="L1923">			return false;</span>
		} else {
<span class="nc bnc" id="L1925" title="All 2 branches missed.">			return defenderPower &lt; otherPower;</span>
		}
	}

	/**
	 * Finds the closest &lt;code&gt;Location&lt;/code&gt; to this tile where this ship can
	 * be repaired, excluding the current colony.
	 *
	 * @return The closest &lt;code&gt;Location&lt;/code&gt; where a ship can be repaired.
	 */
	public Location getRepairLocation() {
<span class="nc" id="L1936">		final Player player = getOwner();</span>
<span class="nc" id="L1937">		final Colony notHere = getTile().getColony();</span>
<span class="nc" id="L1938">		Location best = getClosestColony(player</span>
<span class="nc" id="L1939">				.getColonies()</span>
<span class="nc" id="L1940">				.stream()</span>
<span class="nc bnc" id="L1941" title="All 4 branches missed.">				.filter(c -&gt; c != notHere &amp;&amp; c.hasAbility(Ability.REPAIR_UNITS)));</span>
<span class="nc bnc" id="L1942" title="All 2 branches missed.">		return (best != null) ? best : player.getEurope();</span>
	}

	// Movement handling

	/**
	 * A move type.
	 *
	 * @see Unit#getMoveType(Direction)
	 */
<span class="nc" id="L1952">	public static enum MoveType {</span>
<span class="nc" id="L1953">		MOVE(null, true), MOVE_HIGH_SEAS(null, true), EXPLORE_LOST_CITY_RUMOUR(</span>
<span class="nc" id="L1954">				null, true), ATTACK_UNIT(null, false), ATTACK_SETTLEMENT(null,</span>
<span class="nc" id="L1955">				false), EMBARK(null, false), ENTER_INDIAN_SETTLEMENT_WITH_FREE_COLONIST(</span>
<span class="nc" id="L1956">				null, false), ENTER_INDIAN_SETTLEMENT_WITH_SCOUT(null, false), ENTER_INDIAN_SETTLEMENT_WITH_MISSIONARY(</span>
<span class="nc" id="L1957">				null, false), ENTER_FOREIGN_COLONY_WITH_SCOUT(null, false), ENTER_SETTLEMENT_WITH_CARRIER_AND_GOODS(</span>
<span class="nc" id="L1958">				null, false), MOVE_NO_MOVES(</span>
<span class="nc" id="L1959">				&quot;Attempt to move without moves left&quot;), MOVE_NO_ACCESS_LAND(</span>
<span class="nc" id="L1960">				&quot;Attempt to move a naval unit onto land&quot;), MOVE_NO_ACCESS_BEACHED(</span>
<span class="nc" id="L1961">				&quot;Attempt to move onto foreign beached ship&quot;), MOVE_NO_ACCESS_EMBARK(</span>
<span class="nc" id="L1962">				&quot;Attempt to embark onto absent or foreign carrier&quot;), MOVE_NO_ACCESS_FULL(</span>
<span class="nc" id="L1963">				&quot;Attempt to embark onto full carrier&quot;), MOVE_NO_ACCESS_GOODS(</span>
<span class="nc" id="L1964">				&quot;Attempt to trade without goods&quot;), MOVE_NO_ACCESS_CONTACT(</span>
<span class="nc" id="L1965">				&quot;Attempt to interact with natives before contact&quot;), MOVE_NO_ACCESS_MISSION_BAN(</span>
<span class="nc" id="L1966">				&quot;Attempt to use missionary at banned settlement&quot;), MOVE_NO_ACCESS_SETTLEMENT(</span>
<span class="nc" id="L1967">				&quot;Attempt to move into foreign settlement&quot;), MOVE_NO_ACCESS_SKILL(</span>
<span class="nc" id="L1968">				&quot;Attempt to learn skill with incapable unit&quot;), MOVE_NO_ACCESS_TRADE(</span>
<span class="nc" id="L1969">				&quot;Attempt to trade without authority&quot;), MOVE_NO_ACCESS_WAR(</span>
<span class="nc" id="L1970">				&quot;Attempt to trade while at war&quot;), MOVE_NO_ACCESS_WATER(</span>
<span class="nc" id="L1971">				&quot;Attempt to move into a settlement by water&quot;), MOVE_NO_ATTACK_CIVILIAN(</span>
<span class="nc" id="L1972">				&quot;Attempt to attack with civilian unit&quot;), MOVE_NO_ATTACK_MARINE(</span>
<span class="nc" id="L1973">				&quot;Attempt to attack from on board ship&quot;), MOVE_NO_EUROPE(</span>
<span class="nc" id="L1974">				&quot;Attempt to move to Europe by incapable unit&quot;), MOVE_NO_REPAIR(</span>
<span class="nc" id="L1975">				&quot;Attempt to move a unit that is under repair&quot;), MOVE_NO_TILE(</span>
<span class="nc" id="L1976">				&quot;Attempt to move when not on a tile&quot;), MOVE_ILLEGAL(</span>
<span class="nc" id="L1977">				&quot;Unspecified illegal move&quot;);</span>

		/**
		 * The reason why this move type is illegal.
		 */
		private final String reason;

		/**
		 * Does this move type imply progress towards a destination.
		 */
		private final boolean progress;

<span class="nc" id="L1989">		MoveType(String reason) {</span>
<span class="nc" id="L1990">			this.reason = reason;</span>
<span class="nc" id="L1991">			this.progress = false;</span>
<span class="nc" id="L1992">		}</span>

<span class="nc" id="L1994">		MoveType(String reason, boolean progress) {</span>
<span class="nc" id="L1995">			this.reason = reason;</span>
<span class="nc" id="L1996">			this.progress = progress;</span>
<span class="nc" id="L1997">		}</span>

		public boolean isLegal() {
<span class="nc bnc" id="L2000" title="All 2 branches missed.">			return this.reason == null;</span>
		}

		public String whyIllegal() {
<span class="nc bnc" id="L2004" title="All 2 branches missed.">			return (reason == null) ? &quot;(none)&quot; : reason;</span>
		}

		public boolean isProgress() {
<span class="nc" id="L2008">			return progress;</span>
		}

		public boolean isAttack() {
<span class="nc bnc" id="L2012" title="All 4 branches missed.">			return this == ATTACK_UNIT || this == ATTACK_SETTLEMENT;</span>
		}
	}

	/**
	 * Gets the cost of moving this &lt;code&gt;Unit&lt;/code&gt; onto the given
	 * &lt;code&gt;Tile&lt;/code&gt;. A call to {@link #getMoveType(Tile)} will return
	 * &lt;code&gt;MOVE_NO_MOVES&lt;/code&gt;, if {@link #getMoveCost} returns a move cost
	 * larger than the {@link #getMovesLeft moves left}.
	 *
	 * @param target
	 *            The &lt;code&gt;Tile&lt;/code&gt; this &lt;code&gt;Unit&lt;/code&gt; will move onto.
	 * @return The cost of moving this unit onto the given &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public int getMoveCost(Tile target) {
<span class="nc" id="L2027">		return getMoveCost(getTile(), target, getMovesLeft());</span>
	}

	/**
	 * Gets the cost of moving this &lt;code&gt;Unit&lt;/code&gt; from the given
	 * &lt;code&gt;Tile&lt;/code&gt; onto the given &lt;code&gt;Tile&lt;/code&gt;. A call to
	 * {@link #getMoveType(Tile, Tile, int)} will return
	 * &lt;code&gt;MOVE_NO_MOVES&lt;/code&gt;, if {@link #getMoveCost} returns a move cost
	 * larger than the {@link #getMovesLeft moves left}.
	 *
	 * @param from
	 *            The &lt;code&gt;Tile&lt;/code&gt; this &lt;code&gt;Unit&lt;/code&gt; will move from.
	 * @param target
	 *            The &lt;code&gt;Tile&lt;/code&gt; this &lt;code&gt;Unit&lt;/code&gt; will move onto.
	 * @param ml
	 *            The amount of moves this Unit has left.
	 * @return The cost of moving this unit onto the given &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public int getMoveCost(Tile from, Tile target, int ml) {
		// Remember to also change map.findPath(...) if you change anything
		// here.

<span class="nc" id="L2049">		int cost = target.getType().getBasicMoveCost();</span>
<span class="nc bnc" id="L2050" title="All 4 branches missed.">		if (target.isLand() &amp;&amp; !isNaval()) {</span>
<span class="nc" id="L2051">			TileItemContainer container = target.getTileItemContainer();</span>
<span class="nc bnc" id="L2052" title="All 2 branches missed.">			if (container != null) {</span>
<span class="nc" id="L2053">				cost = container.getMoveCost(from, target, cost);</span>
			}
		}

<span class="nc bnc" id="L2057" title="All 2 branches missed.">		if (isBeached(from)) {</span>
			// Ship on land due to it was in a colony which was abandoned
<span class="nc" id="L2059">			cost = ml;</span>
<span class="nc bnc" id="L2060" title="All 2 branches missed.">		} else if (cost &gt; ml) {</span>
			// Using +2 in order to make 1/3 and 2/3 move count as
			// 3/3, only when getMovesLeft &gt; 0
<span class="nc bnc" id="L2063" title="All 4 branches missed.">			if ((ml + 2 &gt;= getInitialMovesLeft() || cost &lt;= ml + 2 || target</span>
<span class="nc bnc" id="L2064" title="All 4 branches missed.">					.hasSettlement()) &amp;&amp; ml != 0) {</span>
<span class="nc" id="L2065">				cost = ml;</span>
			}
		}
<span class="nc" id="L2068">		return cost;</span>
	}

	/**
	 * Gets the type of a move made in a specified direction.
	 *
	 * @param direction
	 *            The &lt;code&gt;Direction&lt;/code&gt; of the move.
	 * @return The move type.
	 */
	public MoveType getMoveType(Direction direction) {
		Tile target;
<span class="nc bnc" id="L2080" title="All 2 branches missed.">		return (!hasTile()) ? MoveType.MOVE_NO_TILE</span>
<span class="nc bnc" id="L2081" title="All 2 branches missed.">				: ((target = getTile().getNeighbourOrNull(direction)) == null) ? MoveType.MOVE_ILLEGAL</span>
<span class="nc" id="L2082">						: getMoveType(target);</span>
	}

	/**
	 * Gets the type of a move that is made when moving from one tile to
	 * another.
	 *
	 * @param target
	 *            The target &lt;code&gt;Tile&lt;/code&gt; of the move.
	 * @return The move type.
	 */
	public MoveType getMoveType(Tile target) {
<span class="nc bnc" id="L2094" title="All 2 branches missed.">		return (!hasTile()) ? MoveType.MOVE_NO_TILE : getMoveType(getTile(),</span>
<span class="nc" id="L2095">				target, getMovesLeft());</span>
	}

	/**
	 * Gets the type of a move that is made when moving from one tile to
	 * another.
	 *
	 * @param from
	 *            The origin &lt;code&gt;Tile&lt;/code&gt; of the move.
	 * @param target
	 *            The target &lt;code&gt;Tile&lt;/code&gt; of the move.
	 * @param ml
	 *            The amount of moves this unit has left.
	 * @return The move type.
	 */
	public MoveType getMoveType(Tile from, Tile target, int ml) {
<span class="nc" id="L2111">		MoveType move = getSimpleMoveType(from, target);</span>
<span class="nc bnc" id="L2112" title="All 2 branches missed.">		if (move.isLegal()) {</span>
<span class="nc bnc" id="L2113" title="All 2 branches missed.">			switch (move) {</span>
			case ATTACK_UNIT:
			case ATTACK_SETTLEMENT:
				// Needs only a single movement point, regardless of
				// terrain, but suffers penalty.
<span class="nc bnc" id="L2118" title="All 2 branches missed.">				if (ml &lt;= 0) {</span>
<span class="nc" id="L2119">					move = MoveType.MOVE_NO_MOVES;</span>
				}
<span class="nc" id="L2121">				break;</span>
			default:
<span class="nc bnc" id="L2123" title="All 2 branches missed.">				if (ml &lt;= 0</span>
<span class="nc bnc" id="L2124" title="All 4 branches missed.">						|| (from != null &amp;&amp; getMoveCost(from, target, ml) &gt; ml)) {</span>
<span class="nc" id="L2125">					move = MoveType.MOVE_NO_MOVES;</span>
				}
				break;
			}
		}
<span class="nc" id="L2130">		return move;</span>
	}

	/**
	 * Gets the type of a move that is made when moving from one tile to
	 * another, without checking if the unit has moves left or logging errors.
	 *
	 * @param from
	 *            The origin &lt;code&gt;Tile&lt;/code&gt; of the move.
	 * @param target
	 *            The target &lt;code&gt;Tile&lt;/code&gt; of the move.
	 * @return The move type, which will be one of the extended illegal move
	 *         types on failure.
	 */
	public MoveType getSimpleMoveType(Tile from, Tile target) {
<span class="nc bnc" id="L2145" title="All 2 branches missed.">		return (isNaval()) ? getNavalMoveType(from, target) : getLandMoveType(</span>
<span class="nc" id="L2146">				from, target);</span>
	}

	/**
	 * Gets the type of a move that is made when moving from one tile to
	 * another, without checking if the unit has moves left or logging errors.
	 *
	 * @param target
	 *            The target &lt;code&gt;Tile&lt;/code&gt; of the move.
	 * @return The move type, which will be one of the extended illegal move
	 *         types on failure.
	 */
	public MoveType getSimpleMoveType(Tile target) {
<span class="nc bnc" id="L2159" title="All 2 branches missed.">		return (!hasTile()) ? MoveType.MOVE_NO_TILE : getSimpleMoveType(</span>
<span class="nc" id="L2160">				getTile(), target);</span>
	}

	/**
	 * Gets the type of a move made in a specified direction, without checking
	 * if the unit has moves left or logging errors.
	 *
	 * @param direction
	 *            The direction of the move.
	 * @return The move type.
	 */
	public MoveType getSimpleMoveType(Direction direction) {
		Tile target;
<span class="nc bnc" id="L2173" title="All 2 branches missed.">		return (!hasTile()) ? MoveType.MOVE_NO_TILE</span>
<span class="nc bnc" id="L2174" title="All 2 branches missed.">				: ((target = getTile().getNeighbourOrNull(direction)) == null) ? MoveType.MOVE_ILLEGAL</span>
<span class="nc" id="L2175">						: getSimpleMoveType(getTile(), target);</span>
	}

	/**
	 * Gets the type of a move that is made when moving a naval unit from one
	 * tile to another.
	 *
	 * @param from
	 *            The origin &lt;code&gt;Tile&lt;/code&gt; of the move.
	 * @param target
	 *            The target &lt;code&gt;Tile&lt;/code&gt; of the move.
	 * @return The move type.
	 */
	private MoveType getNavalMoveType(Tile from,
			Tile target) {
<span class="nc bnc" id="L2190" title="All 2 branches missed.">		if (target == null) {</span>
<span class="nc bnc" id="L2191" title="All 2 branches missed.">			return (getOwner().canMoveToEurope()) ? MoveType.MOVE_HIGH_SEAS</span>
<span class="nc" id="L2192">					: MoveType.MOVE_NO_EUROPE;</span>
<span class="nc bnc" id="L2193" title="All 2 branches missed.">		} else if (isDamaged()) {</span>
<span class="nc" id="L2194">			return MoveType.MOVE_NO_REPAIR;</span>
		}

<span class="nc bnc" id="L2197" title="All 2 branches missed.">		if (target.isLand()) {</span>
<span class="nc" id="L2198">			Settlement settlement = target.getSettlement();</span>
<span class="nc bnc" id="L2199" title="All 2 branches missed.">			if (settlement == null) {</span>
<span class="nc" id="L2200">				return MoveType.MOVE_NO_ACCESS_LAND;</span>
<span class="nc bnc" id="L2201" title="All 2 branches missed.">			} else if (settlement.getOwner() == getOwner()) {</span>
<span class="nc" id="L2202">				return MoveType.MOVE;</span>
<span class="nc bnc" id="L2203" title="All 2 branches missed.">			} else if (isTradingUnit()) {</span>
<span class="nc" id="L2204">				return getTradeMoveType(settlement);</span>
			} else {
<span class="nc" id="L2206">				return MoveType.MOVE_NO_ACCESS_SETTLEMENT;</span>
			}
		} else { // target at sea
<span class="nc" id="L2209">			Unit defender = target.getFirstUnit();</span>
<span class="nc bnc" id="L2210" title="All 4 branches missed.">			if (defender != null &amp;&amp; !getOwner().owns(defender)) {</span>
<span class="nc bnc" id="L2211" title="All 2 branches missed.">				return (isOffensiveUnit()) ? MoveType.ATTACK_UNIT</span>
<span class="nc" id="L2212">						: MoveType.MOVE_NO_ATTACK_CIVILIAN;</span>
			} else {
<span class="nc bnc" id="L2214" title="All 2 branches missed.">				return (target.isDirectlyHighSeasConnected()) ? MoveType.MOVE_HIGH_SEAS</span>
<span class="nc" id="L2215">						: MoveType.MOVE;</span>
			}
		}
	}

	/**
	 * Gets the type of a move that is made when moving a land unit to from one
	 * tile to another.
	 *
	 * @param from
	 *            The origin &lt;code&gt;Tile&lt;/code&gt; of the move.
	 * @param target
	 *            The target &lt;code&gt;Tile&lt;/code&gt; of the move.
	 * @return The move type.
	 */
	private MoveType getLandMoveType(Tile from, Tile target) {
<span class="nc bnc" id="L2231" title="All 2 branches missed.">		if (target == null)</span>
<span class="nc" id="L2232">			return MoveType.MOVE_ILLEGAL;</span>

<span class="nc" id="L2234">		Player owner = getOwner();</span>
<span class="nc" id="L2235">		Unit defender = target.getFirstUnit();</span>

<span class="nc bnc" id="L2237" title="All 2 branches missed.">		if (target.isLand()) {</span>
<span class="nc" id="L2238">			Settlement settlement = target.getSettlement();</span>
<span class="nc bnc" id="L2239" title="All 2 branches missed.">			if (settlement == null) {</span>
<span class="nc bnc" id="L2240" title="All 4 branches missed.">				if (defender != null &amp;&amp; owner != defender.getOwner()) {</span>
<span class="nc bnc" id="L2241" title="All 2 branches missed.">					if (defender.isNaval()) {</span>
<span class="nc" id="L2242">						return MoveType.ATTACK_UNIT;</span>
<span class="nc bnc" id="L2243" title="All 2 branches missed.">					} else if (!isOffensiveUnit()) {</span>
<span class="nc" id="L2244">						return MoveType.MOVE_NO_ATTACK_CIVILIAN;</span>
					} else {
<span class="nc bnc" id="L2246" title="All 2 branches missed.">						return (allowMoveFrom(from)) ? MoveType.ATTACK_UNIT</span>
<span class="nc" id="L2247">								: MoveType.MOVE_NO_ATTACK_MARINE;</span>
					}
<span class="nc bnc" id="L2249" title="All 4 branches missed.">				} else if (target.hasLostCityRumour() &amp;&amp; owner.isEuropean()) {</span>
					// Natives do not explore rumours, see:
					// server/control/InGameInputHandler.java:move()
<span class="nc" id="L2252">					return MoveType.EXPLORE_LOST_CITY_RUMOUR;</span>
				} else {
<span class="nc" id="L2254">					return MoveType.MOVE;</span>
				}
<span class="nc bnc" id="L2256" title="All 2 branches missed.">			} else if (owner == settlement.getOwner()) {</span>
<span class="nc" id="L2257">				return MoveType.MOVE;</span>
<span class="nc bnc" id="L2258" title="All 2 branches missed.">			} else if (isTradingUnit()) {</span>
<span class="nc" id="L2259">				return getTradeMoveType(settlement);</span>
<span class="nc bnc" id="L2260" title="All 2 branches missed.">			} else if (isColonist()) {</span>
<span class="nc bnc" id="L2261" title="All 2 branches missed.">				if (settlement instanceof Colony</span>
<span class="nc bnc" id="L2262" title="All 2 branches missed.">						&amp;&amp; hasAbility(Ability.NEGOTIATE)) {</span>
<span class="nc bnc" id="L2263" title="All 2 branches missed.">					return (allowMoveFrom(from)) ? MoveType.ENTER_FOREIGN_COLONY_WITH_SCOUT</span>
<span class="nc" id="L2264">							: MoveType.MOVE_NO_ACCESS_WATER;</span>
<span class="nc bnc" id="L2265" title="All 2 branches missed.">				} else if (settlement instanceof IndianSettlement</span>
<span class="nc bnc" id="L2266" title="All 2 branches missed.">						&amp;&amp; hasAbility(Ability.SPEAK_WITH_CHIEF)) {</span>
<span class="nc bnc" id="L2267" title="All 2 branches missed.">					return (allowMoveFrom(from)) ? MoveType.ENTER_INDIAN_SETTLEMENT_WITH_SCOUT</span>
<span class="nc" id="L2268">							: MoveType.MOVE_NO_ACCESS_WATER;</span>
<span class="nc bnc" id="L2269" title="All 2 branches missed.">				} else if (isOffensiveUnit()) {</span>
<span class="nc bnc" id="L2270" title="All 2 branches missed.">					return (allowMoveFrom(from)) ? MoveType.ATTACK_SETTLEMENT</span>
<span class="nc" id="L2271">							: MoveType.MOVE_NO_ATTACK_MARINE;</span>
<span class="nc bnc" id="L2272" title="All 2 branches missed.">				} else if (hasAbility(Ability.ESTABLISH_MISSION)) {</span>
<span class="nc" id="L2273">					return getMissionaryMoveType(from, settlement);</span>
				} else {
<span class="nc" id="L2275">					return getLearnMoveType(from, settlement);</span>
				}
<span class="nc bnc" id="L2277" title="All 2 branches missed.">			} else if (isOffensiveUnit()) {</span>
<span class="nc bnc" id="L2278" title="All 2 branches missed.">				return (allowMoveFrom(from)) ? MoveType.ATTACK_SETTLEMENT</span>
<span class="nc" id="L2279">						: MoveType.MOVE_NO_ATTACK_MARINE;</span>
			} else {
<span class="nc" id="L2281">				return MoveType.MOVE_NO_ACCESS_SETTLEMENT;</span>
			}
		} else { // moving to sea, check for embarkation
<span class="nc bnc" id="L2284" title="All 4 branches missed.">			return (defender == null || !getOwner().owns(defender)) ? MoveType.MOVE_NO_ACCESS_EMBARK</span>
<span class="nc bnc" id="L2285" title="All 2 branches missed.">					: (any(target.getUnitList(), u -&gt; u.canAdd(this))) ? MoveType.EMBARK</span>
<span class="nc" id="L2286">							: MoveType.MOVE_NO_ACCESS_FULL;</span>
		}
	}

	/**
	 * Get the &lt;code&gt;MoveType&lt;/code&gt; when moving a trading unit to a settlement.
	 *
	 * @param settlement
	 *            The &lt;code&gt;Settlement&lt;/code&gt; to move to.
	 * @return The appropriate &lt;code&gt;MoveType&lt;/code&gt;.
	 */
	private MoveType getTradeMoveType(Settlement settlement) {
<span class="nc bnc" id="L2298" title="All 2 branches missed.">		if (settlement instanceof Colony) {</span>
<span class="nc bnc" id="L2299" title="All 2 branches missed.">			return (getOwner().atWarWith(settlement.getOwner())) ? MoveType.MOVE_NO_ACCESS_WAR</span>
<span class="nc bnc" id="L2300" title="All 2 branches missed.">					: (!hasAbility(Ability.TRADE_WITH_FOREIGN_COLONIES)) ? MoveType.MOVE_NO_ACCESS_TRADE</span>
<span class="nc" id="L2301">							: MoveType.ENTER_SETTLEMENT_WITH_CARRIER_AND_GOODS;</span>
<span class="nc bnc" id="L2302" title="All 2 branches missed.">		} else if (settlement instanceof IndianSettlement) {</span>
			// Do not block for war, bringing gifts is allowed
<span class="nc bnc" id="L2304" title="All 2 branches missed.">			return (!allowContact(settlement)) ? MoveType.MOVE_NO_ACCESS_CONTACT</span>
<span class="nc bnc" id="L2305" title="All 2 branches missed.">					: (hasGoodsCargo() || getSpecification().getBoolean(</span>
<span class="nc bnc" id="L2306" title="All 2 branches missed.">							GameOptions.EMPTY_TRADERS)) ? MoveType.ENTER_SETTLEMENT_WITH_CARRIER_AND_GOODS</span>
<span class="nc" id="L2307">							: MoveType.MOVE_NO_ACCESS_GOODS;</span>
		} else {
<span class="nc" id="L2309">			return MoveType.MOVE_ILLEGAL; // should not happen</span>
		}
	}

	/**
	 * Get the &lt;code&gt;MoveType&lt;/code&gt; when moving a colonist to a settlement.
	 *
	 * @param from
	 *            The &lt;code&gt;Tile&lt;/code&gt; to move from.
	 * @param settlement
	 *            The &lt;code&gt;Settlement&lt;/code&gt; to move to.
	 * @return The appropriate &lt;code&gt;MoveType&lt;/code&gt;.
	 */
	private MoveType getLearnMoveType(Tile from, Settlement settlement) {
<span class="nc bnc" id="L2323" title="All 2 branches missed.">		if (settlement instanceof Colony) {</span>
<span class="nc" id="L2324">			return MoveType.MOVE_NO_ACCESS_SETTLEMENT;</span>
<span class="nc bnc" id="L2325" title="All 2 branches missed.">		} else if (settlement instanceof IndianSettlement) {</span>
<span class="nc bnc" id="L2326" title="All 2 branches missed.">			return (!allowContact(settlement)) ? MoveType.MOVE_NO_ACCESS_CONTACT</span>
<span class="nc bnc" id="L2327" title="All 2 branches missed.">					: (!allowMoveFrom(from)) ? MoveType.MOVE_NO_ACCESS_WATER</span>
<span class="nc" id="L2328">							: (!getType().canBeUpgraded(null,</span>
<span class="nc bnc" id="L2329" title="All 2 branches missed.">									ChangeType.NATIVES)) ? MoveType.MOVE_NO_ACCESS_SKILL</span>
<span class="nc" id="L2330">									: MoveType.ENTER_INDIAN_SETTLEMENT_WITH_FREE_COLONIST;</span>
		} else {
<span class="nc" id="L2332">			return MoveType.MOVE_ILLEGAL; // should not happen</span>
		}
	}

	/**
	 * Get the &lt;code&gt;MoveType&lt;/code&gt; when moving a missionary to a settlement.
	 *
	 * @param from
	 *            The &lt;code&gt;Tile&lt;/code&gt; to move from.
	 * @param settlement
	 *            The &lt;code&gt;Settlement&lt;/code&gt; to move to.
	 * @return The appropriate &lt;code&gt;MoveType&lt;/code&gt;.
	 */
	private MoveType getMissionaryMoveType(Tile from, Settlement settlement) {
<span class="nc bnc" id="L2346" title="All 2 branches missed.">		if (settlement instanceof Colony) {</span>
<span class="nc" id="L2347">			return MoveType.MOVE_NO_ACCESS_SETTLEMENT;</span>
<span class="nc bnc" id="L2348" title="All 2 branches missed.">		} else if (settlement instanceof IndianSettlement) {</span>
<span class="nc bnc" id="L2349" title="All 2 branches missed.">			return (!allowContact(settlement)) ? MoveType.MOVE_NO_ACCESS_CONTACT</span>
<span class="nc bnc" id="L2350" title="All 2 branches missed.">					: (!allowMoveFrom(from)) ? MoveType.MOVE_NO_ACCESS_WATER</span>
<span class="nc bnc" id="L2351" title="All 2 branches missed.">							: (settlement.getOwner().missionsBanned(getOwner())) ? MoveType.MOVE_NO_ACCESS_MISSION_BAN</span>
<span class="nc" id="L2352">									: MoveType.ENTER_INDIAN_SETTLEMENT_WITH_MISSIONARY;</span>
		} else {
<span class="nc" id="L2354">			return MoveType.MOVE_ILLEGAL; // should not happen</span>
		}
	}

	/**
	 * Is this unit allowed to move from a source tile? Implements the
	 * restrictions on moving from water.
	 *
	 * @param from
	 *            The &lt;code&gt;Tile&lt;/code&gt; to consider.
	 * @return True if the move is allowed.
	 */
	private boolean allowMoveFrom(Tile from) {
<span class="nc bnc" id="L2367" title="All 2 branches missed.">		return from.isLand()</span>
<span class="nc bnc" id="L2368" title="All 2 branches missed.">				|| (!getOwner().isREF() &amp;&amp; getSpecification().getBoolean(</span>
<span class="nc bnc" id="L2369" title="All 2 branches missed.">						GameOptions.AMPHIBIOUS_MOVES));</span>
	}

	/**
	 * Is this unit allowed to contact a settlement?
	 *
	 * @param settlement
	 *            The &lt;code&gt;Settlement&lt;/code&gt; to consider.
	 * @return True if the contact is allowed.
	 */
	private boolean allowContact(Settlement settlement) {
<span class="nc" id="L2380">		return getOwner().hasContacted(settlement.getOwner());</span>
	}

	/**
	 * Does a basic check whether a unit can ever expect to move to a tile.
	 *
	 * @param tile
	 *            The code &lt;code&gt;Tile&lt;/code&gt; to check.
	 * @return True if some sort of legal move to the tile exists, including
	 *         special cases where there is an interaction but the unit does not
	 *         actually move, such as trade.
	 */
	public boolean isTileAccessible(Tile tile) {
<span class="nc bnc" id="L2393" title="All 6 branches missed.">		return (isNaval()) ? (!tile.isLand() || (tile.hasSettlement() &amp;&amp; getOwner()</span>
<span class="nc bnc" id="L2394" title="All 2 branches missed.">				.owns(tile.getSettlement()))) : tile.isLand();</span>
	}

	/**
	 * Gets the amount of moves this unit has at the beginning of each turn.
	 *
	 * @return The amount of moves this unit has at the beginning of each turn.
	 */
	@Override
	public int getInitialMovesLeft() {
<span class="nc" id="L2404">		Turn turn = getGame().getTurn();</span>
<span class="nc" id="L2405">		return (int) applyModifiers(unitType.getMovement(), turn,</span>
<span class="nc" id="L2406">				Modifier.MOVEMENT_BONUS, unitType);</span>
	}

	/**
	 * Make a label showing the unit moves left.
	 *
	 * @return A movement label.
	 */
	public String getMovesAsString() {
<span class="nc" id="L2415">		StringBuilder sb = new StringBuilder(16);</span>
<span class="nc" id="L2416">		int quotient = getMovesLeft() / 3;</span>
<span class="nc" id="L2417">		int remainder = getMovesLeft() % 3;</span>
<span class="nc bnc" id="L2418" title="All 4 branches missed.">		if (quotient &gt; 0 || remainder == 0)</span>
<span class="nc" id="L2419">			sb.append(quotient);</span>
<span class="nc bnc" id="L2420" title="All 2 branches missed.">		if (remainder &gt; 0) {</span>
<span class="nc" id="L2421">			sb.append(&quot;(&quot;).append(remainder).append(&quot;/3) &quot;);</span>
		}
<span class="nc" id="L2423">		sb.append(&quot;/&quot;).append(getInitialMovesLeft() / 3);</span>
<span class="nc" id="L2424">		return sb.toString();</span>
	}

	/**
	 * Gets the number of turns this unit will need to sail to/from Europe.
	 *
	 * @return The number of turns to sail to/from Europe.
	 */
	public int getSailTurns() {
<span class="nc" id="L2433">		float base = getSpecification().getInteger(GameOptions.TURNS_TO_SAIL);</span>
<span class="nc" id="L2434">		return (int) getOwner().applyModifiers(base, getGame().getTurn(),</span>
<span class="nc" id="L2435">				Modifier.SAIL_HIGH_SEAS, unitType);</span>
	}

	/**
	 * Checks if this &lt;code&gt;Unit&lt;/code&gt; can be moved to the high seas from its
	 * current location.
	 *
	 * @return True if this unit can move immediately to the high seas.
	 */
	public boolean canMoveToHighSeas() {
<span class="nc bnc" id="L2445" title="All 4 branches missed.">		if (isInEurope() || isAtSea())</span>
<span class="nc" id="L2446">			return true;</span>
<span class="nc bnc" id="L2447" title="All 4 branches missed.">		if (!getOwner().canMoveToEurope() || !getType().canMoveToHighSeas())</span>
<span class="nc" id="L2448">			return false;</span>
<span class="nc" id="L2449">		return getTile().isDirectlyHighSeasConnected();</span>
	}

	/**
	 * Does this unit have a valid move to the high seas this turn.
	 *
	 * @return True if the unit can either move immediately to the high seas or
	 *         can make a move to a neighbouring high seas tile.
	 */
	public boolean hasHighSeasMove() {
<span class="nc bnc" id="L2459" title="All 2 branches missed.">		return (canMoveToHighSeas()) ? true</span>
<span class="nc bnc" id="L2460" title="All 4 branches missed.">				: (hasTile() &amp;&amp; getMovesLeft() &gt; 0) ? any(getTile()</span>
<span class="nc" id="L2461">						.getSurroundingTiles(1, 1),</span>
<span class="nc" id="L2462">						Tile::isDirectlyHighSeasConnected) : false;</span>
	}

	/**
	 * Check if this unit can build a colony. Does not consider whether the tile
	 * where the unit is located is suitable,
	 * 
	 * @see Player#canClaimToFoundSettlement(Tile)
	 *
	 * @return &lt;code&gt;true&lt;/code&gt; if this unit can build a colony.
	 */
	public boolean canBuildColony() {
<span class="nc" id="L2474">		final Specification spec = getSpecification();</span>
<span class="nc bnc" id="L2475" title="All 2 branches missed.">		return hasTile()</span>
<span class="nc bnc" id="L2476" title="All 2 branches missed.">				&amp;&amp; unitType.canBuildColony()</span>
<span class="nc bnc" id="L2477" title="All 2 branches missed.">				&amp;&amp; getMovesLeft() &gt; 0</span>
<span class="nc bnc" id="L2478" title="All 2 branches missed.">				&amp;&amp; (!getOwner().isRebel() || spec</span>
<span class="nc bnc" id="L2479" title="All 2 branches missed.">						.getBoolean(GameOptions.FOUND_COLONY_DURING_REBELLION));</span>
	}

	/**
	 * Is this unit at a specified location?
	 *
	 * @param loc
	 *            The &lt;code&gt;Location&lt;/code&gt; to test.
	 * @return True if the locations are the same, or on the same tile.
	 */
	public boolean isAtLocation(Location loc) {
<span class="nc bnc" id="L2490" title="All 2 branches missed.">		Location ourLoc = getLocation(), otherLoc = (loc instanceof Unit) ? ((Unit) loc)</span>
<span class="nc" id="L2491">				.getLocation() : loc;</span>
<span class="nc bnc" id="L2492" title="All 2 branches missed.">		if (ourLoc instanceof Unit)</span>
<span class="nc" id="L2493">			ourLoc = ((Unit) ourLoc).getLocation();</span>
<span class="nc" id="L2494">		return Map.isSameLocation(ourLoc, otherLoc);</span>
	}

	/**
	 * Gets the best (closest) entry location for this unit to reach a given
	 * tile.
	 *
	 * @param tile
	 *            The target &lt;code&gt;Tile&lt;/code&gt;.
	 * @return The best entry location tile to arrive on the map at, or null if
	 *         none found.
	 */
	public Tile getBestEntryTile(Tile tile) {
<span class="nc" id="L2507">		return getGame().getMap().getBestEntryTile(this, tile, null, null);</span>
	}

	/**
	 * Resolves a destination for a unit on the high seas. That is, the location
	 * where the unit will appear when it leaves the high seas, which will
	 * either be Europe or a tile.
	 *
	 * @return The location the unit should appear next after leaving the high
	 *         seas.
	 */
	public Location resolveDestination() {
<span class="nc bnc" id="L2519" title="All 2 branches missed.">		if (!isAtSea())</span>
<span class="nc" id="L2520">			throw new IllegalArgumentException(&quot;Not at sea.&quot;);</span>
<span class="nc" id="L2521">		TradeRouteStop stop = getStop();</span>
<span class="nc bnc" id="L2522" title="All 2 branches missed.">		Location dst = (TradeRoute.isStopValid(this, stop)) ? stop</span>
<span class="nc" id="L2523">				.getLocation() : getDestination();</span>
		Tile best;
<span class="nc bnc" id="L2525" title="All 2 branches missed.">		return (dst == null) ? getFullEntryLocation()</span>
<span class="nc bnc" id="L2526" title="All 2 branches missed.">				: (dst instanceof Europe) ? dst</span>
<span class="nc bnc" id="L2527" title="All 4 branches missed.">						: (dst.getTile() != null &amp;&amp; (best = getBestEntryTile(dst</span>
<span class="nc" id="L2528">								.getTile())) != null) ? best</span>
<span class="nc" id="L2529">								: getFullEntryLocation();</span>
	}

	/**
	 * Set movesLeft to 0 if has some spent moves and it's in a colony
	 *
	 * @see #add(Locatable)
	 * @see #remove(Locatable)
	 */
	private void spendAllMoves() {
<span class="nc bnc" id="L2539" title="All 4 branches missed.">		if (getColony() != null &amp;&amp; getMovesLeft() &lt; getInitialMovesLeft()) {</span>
<span class="nc" id="L2540">			setMovesLeft(0);</span>
		}
<span class="nc" id="L2542">	}</span>

	/**
	 * Is this unit ready to operate a trade route?
	 *
	 * @return True if the unit is ready to trade.
	 */
	public boolean isReadyToTrade() {
<span class="nc bnc" id="L2550" title="All 10 branches missed.">		return !isDisposed() &amp;&amp; !isDamaged() &amp;&amp; !isAtSea() &amp;&amp; !isOnCarrier()</span>
<span class="nc bnc" id="L2551" title="All 4 branches missed.">				&amp;&amp; !isInColony() &amp;&amp; getTradeRoute() != null</span>
<span class="nc bnc" id="L2552" title="All 2 branches missed.">				&amp;&amp; getState() != Unit.UnitState.FORTIFYING</span>
<span class="nc bnc" id="L2553" title="All 2 branches missed.">				&amp;&amp; getState() != Unit.UnitState.SKIPPED &amp;&amp; getMovesLeft() &gt; 0;</span>
	}

	/**
	 * Basic checks for whether a unit is usable ATM.
	 *
	 * @return True if the unit might be useful at present.
	 */
	private boolean readyAndAble() {
<span class="nc bnc" id="L2562" title="All 10 branches missed.">		return !isDisposed() &amp;&amp; !isDamaged() &amp;&amp; !isAtSea() &amp;&amp; !isOnCarrier()</span>
<span class="nc bnc" id="L2563" title="All 4 branches missed.">				&amp;&amp; !isInColony() &amp;&amp; getState() == UnitState.ACTIVE</span>
<span class="nc" id="L2564">				&amp;&amp; getMovesLeft() &gt; 0;</span>
	}

	/**
	 * Is this unit a suitable `next active unit', that is, the unit needs to be
	 * currently movable by the player.
	 *
	 * Used as a predicate in Player.nextActiveUnitIterator.
	 *
	 * @return True if this unit could still be moved by the player.
	 */
	public boolean couldMove() {
<span class="nc bnc" id="L2576" title="All 4 branches missed.">		return readyAndAble() &amp;&amp; getDestination() == null</span>
<span class="nc bnc" id="L2577" title="All 2 branches missed.">				&amp;&amp; getTradeRoute() == null;</span>
	}

	/**
	 * Is this unit a suitable `going-to unit', that is, the unit needs have a
	 * valid destination and be able to progress towards it.
	 *
	 * Used as a predicate in Player.nextGoingToUnitIterator.
	 *
	 * @return True if this unit can go to its destination.
	 */
	public boolean goingToDestination() {
<span class="nc bnc" id="L2589" title="All 4 branches missed.">		return readyAndAble() &amp;&amp; getTradeRoute() == null</span>
<span class="nc bnc" id="L2590" title="All 2 branches missed.">				&amp;&amp; getDestination() != null;</span>
	}

	/**
	 * Is this unit available to move along a trade route?
	 *
	 * Used as a predicate in Player.nextTradeRouteUnitIterator.
	 *
	 * @return True if this unit can follow a trade route.
	 */
	public boolean followingTradeRoute() {
<span class="nc bnc" id="L2601" title="All 4 branches missed.">		return readyAndAble() &amp;&amp; getTradeRoute() != null;</span>
		// Trade route code might set destination
	}

	// Map support routines

	/**
	 * Gets a suitable location to start path searches for a unit.
	 *
	 * Must handle all the cases where the unit is off the map, and take account
	 * of the use of a carrier.
	 *
	 * @return A suitable starting location, or null if none found.
	 */
	public Location getPathStartLocation() {
<span class="nc" id="L2616">		final Unit carrier = getCarrier();</span>
<span class="nc" id="L2617">		Location ret = getTile();</span>
<span class="nc bnc" id="L2618" title="All 2 branches missed.">		if (isOnCarrier()) {</span>
<span class="nc bnc" id="L2619" title="All 2 branches missed.">			if (ret != null) {</span>
				; // OK
<span class="nc bnc" id="L2621" title="All 2 branches missed.">			} else if (carrier.getDestination() == null) {</span>
<span class="nc" id="L2622">				ret = null;</span>
<span class="nc bnc" id="L2623" title="All 2 branches missed.">			} else if (carrier.getDestination() instanceof Map) {</span>
<span class="nc" id="L2624">				ret = carrier.getFullEntryLocation();</span>
<span class="nc bnc" id="L2625" title="All 2 branches missed.">			} else if (carrier.getDestination() instanceof Settlement) {</span>
<span class="nc" id="L2626">				ret = carrier.getDestination();</span>
<span class="nc" id="L2627">			} else { // destination must be Europe</span>
<span class="nc" id="L2628">				ret = null;</span>
			}
<span class="nc bnc" id="L2630" title="All 2 branches missed.">		} else if (isNaval()) {</span>
<span class="nc bnc" id="L2631" title="All 2 branches missed.">			if (ret != null) {</span>
				; // OK
<span class="nc bnc" id="L2633" title="All 2 branches missed.">			} else if (getDestination() == null</span>
<span class="nc bnc" id="L2634" title="All 2 branches missed.">					|| getDestination() instanceof Map) {</span>
<span class="nc" id="L2635">				ret = getFullEntryLocation();</span>
<span class="nc bnc" id="L2636" title="All 2 branches missed.">			} else if (getDestination() instanceof Settlement) {</span>
<span class="nc" id="L2637">				ret = getDestination();</span>
<span class="nc" id="L2638">			} else {</span>
<span class="nc" id="L2639">				ret = getFullEntryLocation();</span>
			}
		}
<span class="nc bnc" id="L2642" title="All 2 branches missed.">		if (ret != null)</span>
<span class="nc" id="L2643">			return ret;</span>

		// Must be a land unit not on the map. May have a carrier.
		// Get our nearest settlement to Europe, fallback to any other.
<span class="nc" id="L2647">		final Player owner = getOwner();</span>
<span class="nc" id="L2648">		int bestValue = INFINITY;</span>
<span class="nc bnc" id="L2649" title="All 2 branches missed.">		for (Settlement s : owner.getSettlements()) {</span>
<span class="nc bnc" id="L2650" title="All 2 branches missed.">			if (s.getTile().isHighSeasConnected()) {</span>
<span class="nc" id="L2651">				int value = s.getTile().getHighSeasCount();</span>
<span class="nc bnc" id="L2652" title="All 2 branches missed.">				if (bestValue &gt; value) {</span>
<span class="nc" id="L2653">					bestValue = value;</span>
<span class="nc" id="L2654">					ret = s;</span>
				}
<span class="nc bnc" id="L2656" title="All 2 branches missed.">			} else if (bestValue == INFINITY)</span>
<span class="nc" id="L2657">				ret = s;</span>
		}
<span class="nc bnc" id="L2659" title="All 2 branches missed.">		if (ret != null)</span>
<span class="nc" id="L2660">			return ret;</span>

		// Owner has no settlements. If it is the REF, start from a
		// rebel colony. Prefer the closest port.
<span class="nc bnc" id="L2664" title="All 2 branches missed.">		if (owner.isREF()) {</span>
<span class="nc" id="L2665">			bestValue = INFINITY;</span>
<span class="nc bnc" id="L2666" title="All 2 branches missed.">			for (Player p : owner.getRebels()) {</span>
<span class="nc bnc" id="L2667" title="All 2 branches missed.">				for (Settlement s : p.getSettlements()) {</span>
<span class="nc bnc" id="L2668" title="All 2 branches missed.">					if (s.getTile().isHighSeasConnected()) {</span>
<span class="nc" id="L2669">						int value = s.getTile().getHighSeasCount();</span>
<span class="nc bnc" id="L2670" title="All 2 branches missed.">						if (bestValue &gt; value) {</span>
<span class="nc" id="L2671">							bestValue = value;</span>
<span class="nc" id="L2672">							ret = s;</span>
						}
<span class="nc bnc" id="L2674" title="All 2 branches missed.">					} else if (bestValue == INFINITY)</span>
<span class="nc" id="L2675">						ret = s;</span>
				}
			}
<span class="nc bnc" id="L2678" title="All 2 branches missed.">			if (ret != null)</span>
<span class="nc" id="L2679">				return ret;</span>
		}

		// Desperately find the nearest land to the entry location.
<span class="nc" id="L2683">		Location entry = getFullEntryLocation();</span>
<span class="nc bnc" id="L2684" title="All 4 branches missed.">		if (entry != null &amp;&amp; entry.getTile() != null) {</span>
<span class="nc bnc" id="L2685" title="All 2 branches missed.">			for (Tile t : entry.getTile().getSurroundingTiles(INFINITY)) {</span>
<span class="nc bnc" id="L2686" title="All 2 branches missed.">				if (t.isLand())</span>
<span class="nc" id="L2687">					return t;</span>
			}
		}

<span class="nc" id="L2691">		return null; // Fail</span>
	}

	/**
	 * Should the unit use transport to get to a specified tile?
	 *
	 * True if: - The location is not null - The unit is not naval - The unit is
	 * not there already AND - there is no path OR the path uses an existing
	 * carrier
	 *
	 * @param loc
	 *            The &lt;code&gt;Location&lt;/code&gt; to go to.
	 * @return True if the unit should use transport.
	 */
	public boolean shouldTakeTransportTo(Location loc) {
		PathNode path;
<span class="nc bnc" id="L2707" title="All 2 branches missed.">		return loc != null</span>
<span class="nc bnc" id="L2708" title="All 2 branches missed.">				&amp;&amp; !isNaval()</span>
<span class="nc bnc" id="L2709" title="All 2 branches missed.">				&amp;&amp; !isAtLocation(loc)</span>
<span class="nc bnc" id="L2710" title="All 2 branches missed.">				&amp;&amp; ((path = findPath(getLocation(), loc, getCarrier(), null)) == null || path</span>
<span class="nc bnc" id="L2711" title="All 2 branches missed.">						.usesCarrier());</span>
	}

	/**
	 * Gets the trivial path for this unit. That is, the path to the nearest
	 * available safe settlement.
	 *
	 * @return A path to the trivial target, or null if none found.
	 */
	public PathNode getTrivialPath() {
<span class="nc bnc" id="L2721" title="All 4 branches missed.">		if (isDisposed() || getLocation() == null)</span>
<span class="nc" id="L2722">			return null;</span>
<span class="nc bnc" id="L2723" title="All 2 branches missed.">		if (!isNaval())</span>
<span class="nc" id="L2724">			return findOurNearestSettlement();</span>
<span class="nc" id="L2725">		PathNode path = findOurNearestPort();</span>
<span class="nc bnc" id="L2726" title="All 2 branches missed.">		if (path == null) {</span>
			// This is unusual, but can happen when a ship is up a
			// river and foreign ship creates a blockage downstream.
			// If so, the rational thing to do is to go to a tile
			// where other units can pass and which has the best
			// connectivity to the high seas.
<span class="nc" id="L2732">			Tile tile = getTile();</span>
<span class="nc bnc" id="L2733" title="All 6 branches missed.">			if (tile != null &amp;&amp; tile.isOnRiver() &amp;&amp; tile.isHighSeasConnected()) {</span>
<span class="nc" id="L2734">				path = search(getLocation(),</span>
<span class="nc" id="L2735">						GoalDeciders.getCornerGoalDecider(),</span>
<span class="nc" id="L2736">						CostDeciders.avoidSettlementsAndBlockingUnits(),</span>
<span class="nc" id="L2737">						INFINITY, null);</span>
<span class="nc bnc" id="L2738" title="All 4 branches missed.">				if (path == null &amp;&amp; tile.isRiverCorner()) {</span>
					// Return trivial path if already present.
<span class="nc" id="L2740">					return new PathNode(tile, 0, 0, false, null, null);</span>
				}
			}
		}
<span class="nc" id="L2744">		return path;</span>
	}

	/**
	 * Finds the fastest path from the current location to the specified one. No
	 * carrier is provided, and the default cost decider for this unit is used.
	 *
	 * @param end
	 *            The &lt;code&gt;Location&lt;/code&gt; in which the path ends.
	 * @return A &lt;code&gt;PathNode&lt;/code&gt; from the current location to the end
	 *         location, or null if none found.
	 */
	public PathNode findPath(Location end) {
<span class="nc" id="L2757">		return findPath(getLocation(), end, null, null);</span>
	}

	/**
	 * Finds a quickest path between specified locations, optionally using a
	 * carrier and special purpose cost decider.
	 *
	 * @param start
	 *            The &lt;code&gt;Location&lt;/code&gt; to start at.
	 * @param end
	 *            The &lt;code&gt;Location&lt;/code&gt; to end at.
	 * @param carrier
	 *            An optional carrier &lt;code&gt;Unit&lt;/code&gt; to carry the unit.
	 * @param costDecider
	 *            An optional &lt;code&gt;CostDecider&lt;/code&gt; for determining the
	 *            movement costs (uses default cost deciders for the unit/s if
	 *            not provided).
	 * @return A &lt;code&gt;PathNode&lt;/code&gt;, or null if no path is found.
	 */
	public PathNode findPath(Location start, Location end, Unit carrier,
			CostDecider costDecider) {
<span class="nc" id="L2778">		return getGame().getMap().findPath(this, start, end, carrier,</span>
<span class="nc" id="L2779">				costDecider, null);</span>
	}

	/**
	 * Finds a quickest path to a neighbouring tile to a specified target tile,
	 * optionally using a carrier and special purpose cost decider.
	 *
	 * @param start
	 *            The &lt;code&gt;Location&lt;/code&gt; to start at.
	 * @param end
	 *            The &lt;code&gt;Tile&lt;/code&gt; to end at a neighbour of.
	 * @param carrier
	 *            An optional carrier &lt;code&gt;Unit&lt;/code&gt; to carry the unit.
	 * @param costDecider
	 *            An optional &lt;code&gt;CostDecider&lt;/code&gt; for determining the
	 *            movement costs (uses default cost deciders for the unit/s if
	 *            not provided).
	 * @return A &lt;code&gt;PathNode&lt;/code&gt;, or null if no path is found.
	 */
	public PathNode findPathToNeighbour(Location start, Tile end, Unit carrier,
			CostDecider costDecider) {
<span class="nc" id="L2800">		final Player owner = getOwner();</span>
<span class="nc" id="L2801">		int bestValue = INFINITY;</span>
<span class="nc" id="L2802">		PathNode best = null;</span>
<span class="nc bnc" id="L2803" title="All 2 branches missed.">		for (Tile t : end.getSurroundingTiles(1)) {</span>
<span class="nc bnc" id="L2804" title="All 2 branches missed.">			if (isTileAccessible(t)</span>
<span class="nc bnc" id="L2805" title="All 2 branches missed.">					&amp;&amp; (t.getFirstUnit() == null || owner</span>
<span class="nc bnc" id="L2806" title="All 2 branches missed.">							.owns(t.getFirstUnit()))) {</span>
<span class="nc" id="L2807">				PathNode p = findPath(start, t, carrier, costDecider);</span>
<span class="nc bnc" id="L2808" title="All 4 branches missed.">				if (p != null &amp;&amp; bestValue &gt; p.getTotalTurns()) {</span>
<span class="nc" id="L2809">					bestValue = p.getTotalTurns();</span>
<span class="nc" id="L2810">					best = p;</span>
				}
			}
		}
<span class="nc" id="L2814">		return best;</span>
	}

	/**
	 * Gets the number of turns required for this unit to reach a destination
	 * location from its current position. If the unit is currently on a
	 * carrier, it will be used.
	 *
	 * @param end
	 *            The destination &lt;code&gt;Location&lt;/code&gt;.
	 * @return The number of turns it will take to reach the destination, or
	 *         &lt;code&gt;MANY_TURNS&lt;/code&gt; if no path can be found.
	 */
	public int getTurnsToReach(Location end) {
<span class="nc" id="L2828">		return getTurnsToReach(getLocation(), end);</span>
	}

	/**
	 * Gets the number of turns required for this unit to reach a destination
	 * location from a starting location. If the unit is currently on a carrier,
	 * it will be used.
	 *
	 * @param start
	 *            The &lt;code&gt;Location&lt;/code&gt; to start the search from.
	 * @param end
	 *            The destination &lt;code&gt;Location&lt;/code&gt;.
	 * @return The number of turns it will take to reach the &lt;code&gt;end&lt;/code&gt;,
	 *         or &lt;code&gt;MANY_TURNS&lt;/code&gt; if no path can be found.
	 */
	public int getTurnsToReach(Location start, Location end) {
<span class="nc" id="L2844">		return getTurnsToReach(start, end, getCarrier(),</span>
<span class="nc" id="L2845">				CostDeciders.avoidSettlementsAndBlockingUnits());</span>
	}

	/**
	 * Gets the number of turns required for this unit to reach a destination
	 * location from a starting location, using an optional carrier and cost
	 * decider.
	 *
	 * @param start
	 *            The &lt;code&gt;Location&lt;/code&gt; to start the search from.
	 * @param end
	 *            The destination &lt;code&gt;Location&lt;/code&gt;.
	 * @param carrier
	 *            An optional carrier &lt;code&gt;Unit&lt;/code&gt; to use.
	 * @param costDecider
	 *            An optional &lt;code&gt;CostDecider&lt;/code&gt; to score the path with.
	 * @return The number of turns it will take to reach the &lt;code&gt;end&lt;/code&gt;,
	 *         or &lt;code&gt;MANY_TURNS&lt;/code&gt; if no path can be found.
	 */
	public int getTurnsToReach(Location start, Location end, Unit carrier,
			CostDecider costDecider) {
<span class="nc" id="L2866">		PathNode path = findPath(start, end, carrier, costDecider);</span>
<span class="nc bnc" id="L2867" title="All 2 branches missed.">		return (path == null) ? MANY_TURNS : path.getTotalTurns();</span>
	}

	/**
	 * Get the colony that can be reached by this unit in the least number of
	 * turns.
	 *
	 * @param colonies
	 *            A list of &lt;code&gt;Colony&lt;/code&gt;s.
	 * @return The nearest &lt;code&gt;Colony&lt;/code&gt;, or null if none found.
	 */
	public Colony getClosestColony(List&lt;Colony&gt; colonies) {
<span class="nc" id="L2879">		return getClosestColony(colonies.stream());</span>
	}

	/**
	 * Get the colony that can be reached by this unit in the least number of
	 * turns.
	 *
	 * @param colonies
	 *            A stream of &lt;code&gt;Colony&lt;/code&gt;s.
	 * @return The nearest &lt;code&gt;Colony&lt;/code&gt;, or null if none found.
	 */
	public Colony getClosestColony(Stream&lt;Colony&gt; colonies) {
<span class="nc bnc" id="L2891" title="All 2 branches missed.">		final Comparator&lt;Colony&gt; comp = cachingIntComparator(col -&gt; (col == null) ? MANY_TURNS - 1</span>
<span class="nc" id="L2892">				: this.getTurnsToReach(col));</span>
<span class="nc" id="L2893">		return minimize(Stream.concat(Stream.of((Colony) null), colonies), comp);</span>
	}

	/**
	 * Find a path for this unit to the nearest settlement with the same owner
	 * that is reachable without a carrier.
	 *
	 * @param excludeStart
	 *            If true, ignore any settlement the unit is currently in.
	 * @param range
	 *            An upper bound on the number of moves.
	 * @param coastal
	 *            If true, the settlement must have a path to Europe.
	 * @return The nearest matching settlement if any, otherwise null.
	 */
	public PathNode findOurNearestSettlement(final boolean excludeStart,
			int range, final boolean coastal) {
<span class="nc" id="L2910">		final Player player = getOwner();</span>
<span class="nc bnc" id="L2911" title="All 4 branches missed.">		if (!player.hasSettlements() || !hasTile())</span>
<span class="nc" id="L2912">			return null;</span>
<span class="nc" id="L2913">		return findOurNearestSettlement(getTile(), excludeStart, range, coastal);</span>
	}

	/**
	 * Find a path for this unit to the nearest settlement with the same owner
	 * that is reachable without a carrier.
	 *
	 * @param startTile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to start searching from.
	 * @param excludeStart
	 *            If true, ignore any settlement the unit is currently in.
	 * @param range
	 *            An upper bound on the number of moves.
	 * @param coastal
	 *            If true, the settlement must have a path to Europe.
	 * @return The nearest matching settlement if any, otherwise null.
	 */
	public PathNode findOurNearestSettlement(final Tile startTile,
			final boolean excludeStart, int range, final boolean coastal) {
<span class="nc" id="L2932">		final Player player = getOwner();</span>
<span class="nc bnc" id="L2933" title="All 4 branches missed.">		if (startTile == null || !player.hasSettlements())</span>
<span class="nc" id="L2934">			return null;</span>
<span class="nc" id="L2935">		final GoalDecider gd = new GoalDecider() {</span>

<span class="nc" id="L2937">			private int bestValue = Integer.MAX_VALUE;</span>
<span class="nc" id="L2938">			private PathNode best = null;</span>

			@Override
			public PathNode getGoal() {
<span class="nc" id="L2942">				return best;</span>
			}

			@Override
			public boolean hasSubGoals() {
<span class="nc" id="L2947">				return true;</span>
			}

			@Override
			public boolean check(Unit u, PathNode path) {
<span class="nc" id="L2952">				Tile t = path.getTile();</span>
<span class="nc bnc" id="L2953" title="All 6 branches missed.">				if (t == null || (t == startTile &amp;&amp; excludeStart))</span>
<span class="nc" id="L2954">					return false;</span>
<span class="nc" id="L2955">				Settlement settlement = t.getSettlement();</span>
				int value;
<span class="nc bnc" id="L2957" title="All 4 branches missed.">				if (settlement != null &amp;&amp; player.owns(settlement)</span>
<span class="nc bnc" id="L2958" title="All 4 branches missed.">						&amp;&amp; (!coastal || settlement.isConnectedPort())</span>
<span class="nc bnc" id="L2959" title="All 2 branches missed.">						&amp;&amp; (value = path.getTotalTurns()) &lt; bestValue) {</span>
<span class="nc" id="L2960">					bestValue = value;</span>
<span class="nc" id="L2961">					best = path;</span>
<span class="nc" id="L2962">					return true;</span>
				}
<span class="nc" id="L2964">				return false;</span>
			}
		};
<span class="nc" id="L2967">		return search(startTile, gd, CostDeciders.avoidIllegal(), range, null);</span>
	}

	/**
	 * Find a path for this unit to the nearest settlement with the same owner
	 * that is reachable without a carrier.
	 *
	 * @return A path to the nearest settlement if any, otherwise null.
	 */
	public PathNode findOurNearestSettlement() {
<span class="nc" id="L2977">		return findOurNearestSettlement(false, Integer.MAX_VALUE, false);</span>
	}

	/**
	 * Find a path for this unit to the nearest settlement with the same owner
	 * that is reachable without a carrier and is connected to Europe by sea, or
	 * Europe if it is closer.
	 *
	 * @return A path to the nearest settlement if any, otherwise null (for now
	 *         including if in Europe or at sea).
	 */
	public PathNode findOurNearestPort() {
<span class="nc" id="L2989">		PathNode ePath = null;</span>
<span class="nc" id="L2990">		int eTurns = -1;</span>
<span class="nc" id="L2991">		Europe europe = getOwner().getEurope();</span>
<span class="nc bnc" id="L2992" title="All 2 branches missed.">		if (getType().canMoveToHighSeas()) {</span>
<span class="nc bnc" id="L2993" title="All 2 branches missed.">			ePath = (europe == null) ? null : findPath(europe);</span>
<span class="nc bnc" id="L2994" title="All 2 branches missed.">			eTurns = (ePath == null) ? -1 : ePath.getTotalTurns();</span>
		}
<span class="nc" id="L2996">		PathNode sPath = findOurNearestSettlement(false, INFINITY, true);</span>
<span class="nc bnc" id="L2997" title="All 2 branches missed.">		int sTurns = (sPath == null) ? -1 : sPath.getTotalTurns();</span>
<span class="nc bnc" id="L2998" title="All 4 branches missed.">		return (ePath == null) ? sPath : (sPath == null) ? ePath</span>
<span class="nc bnc" id="L2999" title="All 2 branches missed.">				: (sTurns &lt;= eTurns) ? sPath : ePath;</span>
	}

	/**
	 * Find a path to a settlement nearer to a destination.
	 *
	 * Used to find where to deliver goods to/from inland colonies, or when
	 * blocked.
	 *
	 * @param dst
	 *            The destination &lt;code&gt;Location&lt;/code&gt;.
	 * @return A path to the port, or null if none found.
	 */
	public PathNode findIntermediatePort(Location dst) {
<span class="nc" id="L3013">		final Settlement ignoreSrc = getSettlement();</span>
<span class="nc" id="L3014">		final Settlement ignoreDst = dst.getSettlement();</span>
<span class="nc" id="L3015">		final Tile srcTile = getTile();</span>
<span class="nc" id="L3016">		final Tile dstTile = dst.getTile();</span>
<span class="nc bnc" id="L3017" title="All 2 branches missed.">		final int dstCont = (dstTile == null) ? -1 : dstTile.getContiguity();</span>
<span class="nc" id="L3018">		PathNode path, best = null;</span>
<span class="nc" id="L3019">		int value, bestValue = INFINITY;</span>
		int type;

<span class="nc bnc" id="L3022" title="All 2 branches missed.">		if (isNaval()) {</span>
<span class="nc bnc" id="L3023" title="All 2 branches missed.">			if (!srcTile.isHighSeasConnected()) {</span>
				// On a lake! FIXME: do better
<span class="nc" id="L3025">				type = 0;</span>
<span class="nc bnc" id="L3026" title="All 2 branches missed.">			} else if (dstTile == null) {</span>
				// Carrier must be blocked from high seas
<span class="nc" id="L3028">				type = 1;</span>
<span class="nc bnc" id="L3029" title="All 2 branches missed.">			} else if (dstTile.isHighSeasConnected()) {</span>
				// Carrier is blocked or destination is blocked.
<span class="nc bnc" id="L3031" title="All 2 branches missed.">				type = (getTile().isOnRiver()) ? 1 : 2;</span>
<span class="nc" id="L3032">			} else {</span>
				// Destination must be blocked
<span class="nc" id="L3034">				type = 2;</span>
			}
<span class="nc" id="L3036">		} else {</span>
<span class="nc bnc" id="L3037" title="All 4 branches missed.">			if (dstTile == null || getTile().getContiguity() != dstCont) {</span>
				// Ocean travel will be required
				// If already at port try to improve its connectivity,
				// otherwise go to a port.
<span class="nc bnc" id="L3041" title="All 2 branches missed.">				type = (srcTile.isHighSeasConnected()) ? 1 : 2;</span>
<span class="nc" id="L3042">			} else {</span>
				// Pure land travel, just find a nearer settlement.
<span class="nc" id="L3044">				type = 3;</span>
			}
		}

<span class="nc bnc" id="L3048" title="All 5 branches missed.">		switch (type) {</span>
		case 0:
			// No progress possible.
<span class="nc" id="L3051">			break;</span>
		case 1:
			// Starting on a river, probably blocked in there.
			// Find the settlement that most reduces the high seas count.
<span class="nc" id="L3055">			best = search(getLocation(),</span>
<span class="nc" id="L3056">					GoalDeciders.getReduceHighSeasCountGoalDecider(this), null,</span>
<span class="nc" id="L3057">					INFINITY, null);</span>
<span class="nc" id="L3058">			break;</span>
		case 2:
			// Ocean travel required, destination blocked.
			// Find the closest available connected port.
<span class="nc bnc" id="L3062" title="All 2 branches missed.">			for (Settlement s : getOwner().getSettlements()) {</span>
<span class="nc bnc" id="L3063" title="All 6 branches missed.">				if (s != ignoreSrc &amp;&amp; s != ignoreDst &amp;&amp; s.isConnectedPort()</span>
<span class="nc bnc" id="L3064" title="All 2 branches missed.">						&amp;&amp; (path = findPath(s)) != null) {</span>
<span class="nc" id="L3065">					value = path.getTotalTurns()</span>
<span class="nc" id="L3066">							+ dstTile.getDistanceTo(s.getTile());</span>
<span class="nc bnc" id="L3067" title="All 2 branches missed.">					if (bestValue &gt; value) {</span>
<span class="nc" id="L3068">						bestValue = value;</span>
<span class="nc" id="L3069">						best = path;</span>
					}
				}
			}
<span class="nc" id="L3073">			break;</span>
		case 3:
			// Land travel. Find nearby settlement with correct contiguity.
<span class="nc bnc" id="L3076" title="All 2 branches missed.">			for (Settlement s : getOwner().getSettlements()) {</span>
<span class="nc bnc" id="L3077" title="All 4 branches missed.">				if (s != ignoreSrc &amp;&amp; s != ignoreDst</span>
<span class="nc bnc" id="L3078" title="All 2 branches missed.">						&amp;&amp; s.getTile().getContiguity() == dstCont</span>
<span class="nc bnc" id="L3079" title="All 2 branches missed.">						&amp;&amp; (path = findPath(s)) != null) {</span>
<span class="nc" id="L3080">					value = path.getTotalTurns()</span>
<span class="nc" id="L3081">							+ dstTile.getDistanceTo(s.getTile());</span>
<span class="nc bnc" id="L3082" title="All 2 branches missed.">					if (bestValue &gt; value) {</span>
<span class="nc" id="L3083">						bestValue = value;</span>
<span class="nc" id="L3084">						best = path;</span>
					}
				}
			}
		}
<span class="nc bnc" id="L3089" title="All 2 branches missed.">		return (best != null) ? best : findOurNearestSettlement(false,</span>
<span class="nc" id="L3090">				INFINITY, false);</span>
	}

	/**
	 * Find a path for this unit to the nearest settlement with the same owner
	 * that is reachable without a carrier, excepting any on the current tile.
	 *
	 * @return The nearest settlement if any, otherwise null.
	 */
	public PathNode findOurNearestOtherSettlement() {
<span class="nc" id="L3100">		return findOurNearestSettlement(true, Integer.MAX_VALUE, false);</span>
	}

	/**
	 * Convenience wrapper for the
	 * {@link net.sf.freecol.common.model.Map#search} function.
	 *
	 * @param start
	 *            The &lt;code&gt;Location&lt;/code&gt; to start the search from.
	 * @param gd
	 *            The object responsible for determining whether a given
	 *            &lt;code&gt;PathNode&lt;/code&gt; is a goal or not.
	 * @param cd
	 *            An optional &lt;code&gt;CostDecider&lt;/code&gt; responsible for
	 *            determining the path cost.
	 * @param maxTurns
	 *            The maximum number of turns the given &lt;code&gt;Unit&lt;/code&gt; is
	 *            allowed to move. This is the maximum search range for a goal.
	 * @param carrier
	 *            An optional naval carrier &lt;code&gt;Unit&lt;/code&gt; to use.
	 * @return The path to a goal, or null if none can be found.
	 */
	public PathNode search(Location start, GoalDecider gd, CostDecider cd,
			int maxTurns, Unit carrier) {
<span class="nc bnc" id="L3124" title="All 2 branches missed.">		return (start == null) ? null : getGame().getMap().search(this, start,</span>
<span class="nc" id="L3125">				gd, cd, maxTurns, carrier, null);</span>
	}

	/**
	 * Can this unit attack a specified defender?
	 *
	 * A naval unit can never attack a land unit or settlement, but a land unit
	 * *can* attack a naval unit if it is beached. Otherwise naval units can
	 * only fight at sea, land units only on land.
	 *
	 * @param defender
	 *            The defending &lt;code&gt;Unit&lt;/code&gt;.
	 * @return True if this unit can attack.
	 */
	public boolean canAttack(Unit defender) {
<span class="nc bnc" id="L3140" title="All 6 branches missed.">		if (!isOffensiveUnit() || defender == null || !defender.hasTile())</span>
<span class="nc" id="L3141">			return false;</span>

<span class="nc" id="L3143">		Tile tile = defender.getTile();</span>
<span class="nc bnc" id="L3144" title="All 6 branches missed.">		return (isNaval()) ? !tile.hasSettlement() &amp;&amp; defender.isNaval()</span>
<span class="nc bnc" id="L3145" title="All 4 branches missed.">				: !defender.isNaval() || defender.isBeached();</span>
	}

	/**
	 * Searches for a unit that is a credible threatening unit to this unit
	 * within a range.
	 *
	 * @param range
	 *            The number of turns to search for a threat in.
	 * @param threat
	 *            The maximum tolerable probability of a potentially threatening
	 *            unit defeating this unit in combat.
	 * @return A path to the threat, or null if not found.
	 */
	public PathNode searchForDanger(final int range, final float threat) {
<span class="nc" id="L3160">		final CombatModel cm = getGame().getCombatModel();</span>
<span class="nc" id="L3161">		final Tile start = getTile();</span>
<span class="nc" id="L3162">		final GoalDecider threatDecider = new GoalDecider() {</span>
<span class="nc" id="L3163">			private PathNode found = null;</span>

			@Override
			public PathNode getGoal() {
<span class="nc" id="L3167">				return found;</span>
			}

			@Override
			public boolean hasSubGoals() {
<span class="nc" id="L3172">				return false;</span>
			}

			@Override
			public boolean check(Unit unit, PathNode path) {
<span class="nc" id="L3177">				Tile tile = path.getTile();</span>
<span class="nc bnc" id="L3178" title="All 2 branches missed.">				if (tile == null)</span>
<span class="nc" id="L3179">					return false;</span>
<span class="nc" id="L3180">				Unit first = tile.getFirstUnit();</span>
<span class="nc bnc" id="L3181" title="All 4 branches missed.">				if (first == null || !getOwner().atWarWith(first.getOwner())) {</span>
<span class="nc" id="L3182">					return false;</span>
				}
<span class="nc bnc" id="L3184" title="All 2 branches missed.">				for (Unit u : tile.getUnitList()) {</span>
					PathNode reverse;
<span class="nc bnc" id="L3186" title="All 2 branches missed.">					if (u.canAttack(unit)</span>
<span class="nc bnc" id="L3187" title="All 2 branches missed.">							&amp;&amp; cm.calculateCombatOdds(u, unit).win &gt;= threat</span>
<span class="nc bnc" id="L3188" title="All 2 branches missed.">							&amp;&amp; (reverse = u.findPath(start)) != null</span>
<span class="nc bnc" id="L3189" title="All 2 branches missed.">							&amp;&amp; reverse.getTotalTurns() &lt; range) {</span>
<span class="nc" id="L3190">						found = path;</span>
<span class="nc" id="L3191">						return true;</span>
					}
				}
<span class="nc" id="L3194">				return false;</span>
			}
		};
		// The range to search will depend on the speed of the other
		// unit. We can not know what it will be in advance, and it
		// might be significantly faster than this unit. We do not
		// want to just use an unbounded search range because this
		// routine must be quick (especially when the supplied range
		// is low). So use the heuristic of increasing the range by
		// the ratio of the fastest appropriate (land/naval) unit type
		// speed over the unit speed.
<span class="nc" id="L3205">		int reverseRange = range</span>
<span class="nc bnc" id="L3206" title="All 2 branches missed.">				* (((isNaval()) ? getSpecification().getFastestNavalUnitType()</span>
<span class="nc" id="L3207">						: getSpecification().getFastestLandUnitType())</span>
<span class="nc" id="L3208">						.getMovement()) / this.getType().getMovement();</span>

<span class="nc bnc" id="L3210" title="All 2 branches missed.">		return (start == null) ? null : search(start, threatDecider,</span>
<span class="nc" id="L3211">				CostDeciders.avoidIllegal(), reverseRange, getCarrier());</span>
	}

	/**
	 * Checks if there is a credible threatening unit to this unit within a
	 * range of moves.
	 *
	 * @param range
	 *            The number of turns to search for a threat within.
	 * @param threat
	 *            The maximum tolerable probability of a potentially threatening
	 *            unit defeating this unit in combat.
	 * @return True if a threat was found.
	 */
	public boolean isInDanger(int range, float threat) {
<span class="nc bnc" id="L3226" title="All 2 branches missed.">		return searchForDanger(range, threat) != null;</span>
	}

	/**
	 * Gets the line of sight of this &lt;code&gt;Unit&lt;/code&gt;. That is the distance
	 * this &lt;code&gt;Unit&lt;/code&gt; can sight new tiles.
	 *
	 * @return The line of sight of this &lt;code&gt;Unit&lt;/code&gt;.
	 */
	public int getLineOfSight() {
<span class="nc" id="L3236">		final Turn turn = getGame().getTurn();</span>
<span class="nc" id="L3237">		Set&lt;Modifier&gt; result = new HashSet&lt;&gt;();</span>
<span class="nc" id="L3238">		result.addAll(this.getModifiers(Modifier.LINE_OF_SIGHT_BONUS, unitType,</span>
<span class="nc" id="L3239">				turn));</span>
<span class="nc bnc" id="L3240" title="All 4 branches missed.">		if (hasTile() &amp;&amp; getTile().isExplored()) {</span>
<span class="nc" id="L3241">			result.addAll(getTile().getType().getModifiers(</span>
<span class="nc" id="L3242">					Modifier.LINE_OF_SIGHT_BONUS, unitType, turn));</span>
		}
<span class="nc" id="L3244">		float base = unitType.getLineOfSight();</span>
<span class="nc" id="L3245">		return (int) applyModifiers(base, turn, result);</span>
	}

	// Goods handling

	/**
	 * Get the goods carried by this unit.
	 *
	 * @return A list of &lt;code&gt;Goods&lt;/code&gt;.
	 */
	public List&lt;Goods&gt; getGoodsList() {
<span class="nc bnc" id="L3256" title="All 2 branches missed.">		return (getGoodsContainer() == null) ? Collections.&lt;Goods&gt; emptyList()</span>
<span class="nc" id="L3257">				: getGoodsContainer().getGoods();</span>
	}

	/**
	 * Get a compact version of the goods carried by this unit.
	 *
	 * @return A compact list of &lt;code&gt;Goods&lt;/code&gt;.
	 */
	public List&lt;Goods&gt; getCompactGoodsList() {
<span class="nc bnc" id="L3266" title="All 2 branches missed.">		return (getGoodsContainer() == null) ? Collections.&lt;Goods&gt; emptyList()</span>
<span class="nc" id="L3267">				: getGoodsContainer().getCompactGoods();</span>
	}

	/**
	 * Can this unit carry other units?
	 *
	 * @return True if the unit can carry units.
	 */
	public boolean canCarryUnits() {
<span class="nc" id="L3276">		return hasAbility(Ability.CARRY_UNITS);</span>
	}

	/**
	 * Could this unit carry a specified one? This ignores the current load.
	 *
	 * @param u
	 *            The potential cargo &lt;code&gt;Unit&lt;/code&gt;.
	 * @return True if this unit can carry the cargo.
	 */
	public boolean couldCarry(Unit u) {
<span class="nc bnc" id="L3287" title="All 4 branches missed.">		return canCarryUnits() &amp;&amp; getCargoCapacity() &gt;= u.getSpaceTaken();</span>
	}

	/**
	 * Can this unit carry goods.
	 *
	 * @return True if the unit can carry goods.
	 */
	public boolean canCarryGoods() {
<span class="nc" id="L3296">		return hasAbility(Ability.CARRY_GOODS);</span>
	}

	/**
	 * Could this unit carry some specified goods? This ignores the current
	 * load.
	 *
	 * @param g
	 *            The potential cargo &lt;code&gt;Goods&lt;/code&gt;.
	 * @return True if this unit can carry the cargo.
	 */
	public boolean couldCarry(Goods g) {
<span class="nc bnc" id="L3308" title="All 4 branches missed.">		return canCarryGoods() &amp;&amp; getCargoCapacity() &gt;= g.getSpaceTaken();</span>
	}

	/**
	 * Gets the number of free cargo slots left on this unit.
	 *
	 * @return The number of free cargo slots on this unit.
	 */
	public int getSpaceLeft() {
<span class="nc" id="L3317">		return getCargoCapacity() - getCargoSpaceTaken();</span>
	}

	/**
	 * Is there free space left on this unit?
	 *
	 * @return True if there is free space.
	 */
	public boolean hasSpaceLeft() {
<span class="nc bnc" id="L3326" title="All 2 branches missed.">		return getSpaceLeft() &gt; 0;</span>
	}

	/**
	 * Gets the total space this unit has to carry cargo.
	 *
	 * @return The total space.
	 */
	public int getCargoCapacity() {
<span class="nc" id="L3335">		return unitType.getSpace();</span>
	}

	/**
	 * Gets the space occupied by goods in this unit. Must defend against goods
	 * container being null as this can be called in the client on foreign
	 * units, which will not have goods containers.
	 *
	 * @return The number cargo slots occupied by goods.
	 */
	public int getGoodsSpaceTaken() {
<span class="nc bnc" id="L3346" title="All 2 branches missed.">		if (!canCarryGoods())</span>
<span class="nc" id="L3347">			return 0;</span>
<span class="nc" id="L3348">		GoodsContainer gc = getGoodsContainer();</span>
<span class="nc bnc" id="L3349" title="All 2 branches missed.">		return (gc == null) ? 0 : gc.getSpaceTaken();</span>
	}

	/**
	 * Gets the space occupied by units in this unit.
	 *
	 * @return The number of cargo slots occupied by units.
	 */
	public int getUnitSpaceTaken() {
<span class="nc bnc" id="L3358" title="All 2 branches missed.">		return (canCarryUnits()) ? sum(getUnitList(), u -&gt; u.getSpaceTaken())</span>
<span class="nc" id="L3359">				: 0;</span>
	}

	/**
	 * Gets the space occupied by cargo in this unit (both goods and units).
	 *
	 * @return The number of occupied cargo slots.
	 */
	public int getCargoSpaceTaken() {
<span class="nc" id="L3368">		return getGoodsSpaceTaken() + getUnitSpaceTaken();</span>
	}

	/**
	 * Is this unit carrying any goods cargo?
	 *
	 * @return True if the unit is carrying any goods cargo.
	 */
	public boolean hasGoodsCargo() {
<span class="nc bnc" id="L3377" title="All 2 branches missed.">		return getGoodsSpaceTaken() &gt; 0;</span>
	}

	/**
	 * Is this unit carrying any cargo (goods or unit).
	 *
	 * @return True if the unit is carrying any cargo.
	 */
	public boolean hasCargo() {
<span class="nc bnc" id="L3386" title="All 2 branches missed.">		return getCargoSpaceTaken() &gt; 0;</span>
	}

	/**
	 * Gets the extra amount of a specified type of goods that could be loaded
	 * onto this unit. Includes empty cargo slots and any spare space in a slot
	 * partially filled with the specified goods.
	 *
	 * @param type
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to examine.
	 * @return The amount of goods that could be loaded onto this unit.
	 */
	public int getLoadableAmount(GoodsType type) {
<span class="nc bnc" id="L3399" title="All 2 branches missed.">		if (!canCarryGoods())</span>
<span class="nc" id="L3400">			return 0;</span>
<span class="nc" id="L3401">		int result = getSpaceLeft() * GoodsContainer.CARGO_SIZE;</span>
<span class="nc" id="L3402">		int count = getGoodsCount(type) % GoodsContainer.CARGO_SIZE;</span>
<span class="nc bnc" id="L3403" title="All 2 branches missed.">		if (count != 0)</span>
<span class="nc" id="L3404">			result += GoodsContainer.CARGO_SIZE - count;</span>
<span class="nc" id="L3405">		return result;</span>
	}

	// Miscellaneous more complex functionality

	/**
	 * Get a label for the current unit occupation.
	 *
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt; viewing the unit, as the owner has
	 *            access to more information.
	 * @param full
	 *            If true, return a more detailed result.
	 * @return A &lt;code&gt;StringTemplate&lt;/code&gt; for the unit occupation.
	 */
	public StringTemplate getOccupationLabel(Player player, boolean full) {
<span class="nc" id="L3421">		final TradeRoute tradeRoute = getTradeRoute();</span>
		StringTemplate ret;
<span class="nc bnc" id="L3423" title="All 4 branches missed.">		if (player != null &amp;&amp; player.owns(this)) {</span>
<span class="nc bnc" id="L3424" title="All 2 branches missed.">			if (isDamaged()) {</span>
<span class="nc bnc" id="L3425" title="All 2 branches missed.">				if (full) {</span>
<span class="nc" id="L3426">					ret = StringTemplate.label(&quot;:&quot;)</span>
<span class="nc" id="L3427">							.add(&quot;model.unit.occupation.underRepair&quot;)</span>
<span class="nc" id="L3428">							.addName(String.valueOf(getTurnsForRepair()));</span>
<span class="nc" id="L3429">				} else {</span>
<span class="nc" id="L3430">					ret = StringTemplate</span>
<span class="nc" id="L3431">							.key(&quot;model.unit.occupation.underRepair&quot;);</span>
				}
<span class="nc bnc" id="L3433" title="All 2 branches missed.">			} else if (tradeRoute != null) {</span>
<span class="nc bnc" id="L3434" title="All 2 branches missed.">				if (full) {</span>
<span class="nc" id="L3435">					ret = StringTemplate.label(&quot;:&quot;)</span>
<span class="nc" id="L3436">							.add(&quot;model.unit.occupation.inTradeRoute&quot;)</span>
<span class="nc" id="L3437">							.addName(tradeRoute.getName());</span>
<span class="nc" id="L3438">				} else {</span>
<span class="nc" id="L3439">					ret = StringTemplate</span>
<span class="nc" id="L3440">							.key(&quot;model.unit.occupation.inTradeRoute&quot;);</span>
				}
<span class="nc bnc" id="L3442" title="All 4 branches missed.">			} else if (getState() == UnitState.ACTIVE &amp;&amp; getMovesLeft() == 0) {</span>
<span class="nc" id="L3443">				ret = StringTemplate</span>
<span class="nc" id="L3444">						.key(&quot;model.unit.occupation.activeNoMovesLeft&quot;);</span>
<span class="nc bnc" id="L3445" title="All 2 branches missed.">			} else if (getState() == UnitState.IMPROVING</span>
<span class="nc bnc" id="L3446" title="All 2 branches missed.">					&amp;&amp; getWorkImprovement() != null) {</span>
<span class="nc bnc" id="L3447" title="All 2 branches missed.">				if (full) {</span>
<span class="nc" id="L3448">					ret = StringTemplate</span>
<span class="nc" id="L3449">							.label(&quot;:&quot;)</span>
<span class="nc" id="L3450">							.add(getWorkImprovement().getType()</span>
<span class="nc" id="L3451">									+ &quot;.occupationString&quot;)</span>
<span class="nc" id="L3452">							.addName(String.valueOf(getWorkTurnsLeft()));</span>
<span class="nc" id="L3453">				} else {</span>
<span class="nc" id="L3454">					ret = StringTemplate.key(getWorkImprovement().getType()</span>
<span class="nc" id="L3455">							+ &quot;.occupationString&quot;);</span>
				}
<span class="nc bnc" id="L3457" title="All 2 branches missed.">			} else if (getDestination() != null) {</span>
<span class="nc" id="L3458">				ret = StringTemplate</span>
<span class="nc" id="L3459">						.key(&quot;model.unit.occupation.goingSomewhere&quot;);</span>
<span class="nc" id="L3460">			} else {</span>
<span class="nc" id="L3461">				ret = StringTemplate.key(&quot;model.unit.&quot; + getState().getKey());</span>
			}
<span class="nc" id="L3463">		} else {</span>
<span class="nc bnc" id="L3464" title="All 2 branches missed.">			if (isNaval()) {</span>
<span class="nc" id="L3465">				ret = StringTemplate.name(String</span>
<span class="nc" id="L3466">						.valueOf(getVisibleGoodsCount()));</span>
<span class="nc" id="L3467">			} else {</span>
<span class="nc" id="L3468">				ret = StringTemplate</span>
<span class="nc" id="L3469">						.key(&quot;model.unit.occupation.activeNoMovesLeft&quot;);</span>
			}
		}
<span class="nc" id="L3472">		return ret;</span>
	}

	/**
	 * Gets the probability that an attack by this unit will provoke a native to
	 * convert.
	 *
	 * @return A probability of conversion.
	 */
	public float getConvertProbability() {
<span class="nc" id="L3482">		final Specification spec = getSpecification();</span>
<span class="nc" id="L3483">		int opt = spec.getInteger(GameOptions.NATIVE_CONVERT_PROBABILITY);</span>
<span class="nc" id="L3484">		return 0.01f * applyModifiers(opt, getGame().getTurn(),</span>
<span class="nc" id="L3485">				Modifier.NATIVE_CONVERT_BONUS);</span>
	}

	/**
	 * Gets the probability that an attack by this unit will provoke natives to
	 * burn our missions.
	 *
	 * FIXME: enhance burn probability proportionally with tension
	 *
	 * @return A probability of burning missions.
	 */
	public float getBurnProbability() {
<span class="nc" id="L3497">		final Specification spec = getSpecification();</span>
<span class="nc" id="L3498">		return 0.01f * spec.getInteger(GameOptions.BURN_PROBABILITY);</span>
	}

	/**
	 * Get a type change for this unit.
	 *
	 * @param change
	 *            The &lt;code&gt;ChangeType&lt;/code&gt; to consider.
	 * @param owner
	 *            The &lt;code&gt;Player&lt;/code&gt; to own this unit after a change of
	 *            type CAPTURE or UNDEAD.
	 * @return The resulting unit type or null if there is no change suitable.
	 */
	public UnitType getTypeChange(ChangeType change, Player owner) {
<span class="nc" id="L3512">		return getType().getTargetType(change, owner);</span>
	}

	/**
	 * Checks if the treasure train can be cashed in at it's current
	 * &lt;code&gt;Location&lt;/code&gt;.
	 *
	 * @return &lt;code&gt;true&lt;/code&gt; if the treasure train can be cashed in.
	 * @exception IllegalStateException
	 *                if this unit is not a treasure train.
	 */
	public boolean canCashInTreasureTrain() {
<span class="nc" id="L3524">		return canCashInTreasureTrain(getLocation());</span>
	}

	/**
	 * Checks if the treasure train can be cashed in at the given
	 * &lt;code&gt;Location&lt;/code&gt;.
	 *
	 * @param loc
	 *            The &lt;code&gt;Location&lt;/code&gt;.
	 * @return &lt;code&gt;true&lt;/code&gt; if the treasure train can be cashed in.
	 * @exception IllegalStateException
	 *                if this unit is not a treasure train.
	 */
	public boolean canCashInTreasureTrain(Location loc) {
<span class="nc bnc" id="L3538" title="All 2 branches missed.">		if (!canCarryTreasure()) {</span>
<span class="nc" id="L3539">			throw new IllegalStateException(&quot;Can't carry treasure&quot;);</span>
		}
<span class="nc bnc" id="L3541" title="All 2 branches missed.">		if (loc == null)</span>
<span class="nc" id="L3542">			return false;</span>

<span class="nc bnc" id="L3544" title="All 2 branches missed.">		if (getOwner().getEurope() == null) {</span>
			// Any colony will do once independent, as the treasure stays
			// in the New World.
<span class="nc bnc" id="L3547" title="All 2 branches missed.">			return loc.getColony() != null;</span>
		}
<span class="nc bnc" id="L3549" title="All 2 branches missed.">		if (loc.getColony() != null) {</span>
			// Cash in if at a colony which has connectivity to Europe
			// unless the player has a suitable carrier and no free transport.
<span class="nc bnc" id="L3552" title="All 2 branches missed.">			return loc.getColony().isConnectedPort()</span>
<span class="nc bnc" id="L3553" title="All 4 branches missed.">					&amp;&amp; (getOwner().getCarriersForUnit(this).isEmpty() || getTransportFee() == 0);</span>
		}
		// Otherwise, cash in if in Europe.
<span class="nc bnc" id="L3556" title="All 2 branches missed.">		return loc instanceof Europe</span>
<span class="nc bnc" id="L3557" title="All 4 branches missed.">				|| (loc instanceof Unit &amp;&amp; ((Unit) loc).isInEurope());</span>
	}

	/**
	 * Get the fee that would have to be paid to transport this treasure to
	 * Europe.
	 *
	 * @return The fee required for transport.
	 */
	public int getTransportFee() {
<span class="nc bnc" id="L3567" title="All 4 branches missed.">		if (!isInEurope() &amp;&amp; getOwner().getEurope() != null) {</span>
<span class="nc" id="L3568">			float fee = (getSpecification().getInteger(</span>
<span class="nc" id="L3569">					GameOptions.TREASURE_TRANSPORT_FEE) * getTreasureAmount()) / 100.0f;</span>
<span class="nc" id="L3570">			return (int) getOwner().applyModifiers(fee, getGame().getTurn(),</span>
<span class="nc" id="L3571">					Modifier.TREASURE_TRANSPORT_FEE, unitType);</span>
		}
<span class="nc" id="L3573">		return 0;</span>
	}

	/**
	 * Gets the skill level.
	 *
	 * @return The level of skill for this unit. A higher value signals a more
	 *         advanced type of units.
	 */
	public int getSkillLevel() {
<span class="nc" id="L3583">		return getSkillLevel(unitType);</span>
	}

	/**
	 * Gets the skill level of the given type of &lt;code&gt;Unit&lt;/code&gt;.
	 *
	 * @param unitType
	 *            The type of &lt;code&gt;Unit&lt;/code&gt;.
	 * @return The level of skill for the given unit. A higher value signals a
	 *         more advanced type of units.
	 */
	public static int getSkillLevel(UnitType unitType) {
<span class="nc bnc" id="L3595" title="All 2 branches missed.">		return (unitType.hasSkill()) ? unitType.getSkill() : 0;</span>
	}

	/**
	 * Gets the appropriate trade bonuses due to a missionary unit.
	 *
	 * @param sense
	 *            The sense to apply the modifiers.
	 * @return The missionary trade bonuses.
	 */
	public Set&lt;Modifier&gt; getMissionaryTradeModifiers(boolean sense) {
<span class="nc" id="L3606">		return transform(getModifiers(Modifier.MISSIONARY_TRADE_BONUS),</span>
<span class="nc bnc" id="L3607" title="All 2 branches missed.">				m -&gt; m.getValue() != 0, m -&gt; {</span>
<span class="nc" id="L3608">					Modifier mod = new Modifier(m);</span>
<span class="nc bnc" id="L3609" title="All 2 branches missed.">					if (!sense)</span>
<span class="nc" id="L3610">						mod.setValue(-m.getValue());</span>
<span class="nc" id="L3611">					return mod;</span>
<span class="nc" id="L3612">				}, Collectors.toSet());</span>
	}

	/**
	 * Adds a feature to the Unit. This method always throws an
	 * &lt;code&gt;UnsupportedOperationException&lt;/code&gt;, since features can not be
	 * added to Units directly.
	 *
	 * @param feature
	 *            The &lt;code&gt;Feature&lt;/code&gt; to add.
	 */
	public void addFeature(Feature feature) {
<span class="nc" id="L3624">		throw new UnsupportedOperationException(</span>
<span class="nc" id="L3625">				&quot;Can not add Feature to Unit directly!&quot;);</span>
	}

	/**
	 * Gets the &lt;code&gt;ProductionInfo&lt;/code&gt; for this unit.
	 *
	 * FIXME: the input parameter is ignored! Fix?
	 *
	 * @param input
	 *            A list of input &lt;code&gt;AbstractGoods&lt;/code&gt;.
	 * @return The &lt;code&gt;ProductionInfo&lt;/code&gt; for this unit.
	 */
	public ProductionInfo getProductionInfo(List&lt;AbstractGoods&gt; input) {
<span class="nc" id="L3638">		ProductionInfo result = new ProductionInfo();</span>
<span class="nc" id="L3639">		result.setConsumption(getType().getConsumedGoods());</span>
<span class="nc" id="L3640">		result.setMaximumConsumption(getType().getConsumedGoods());</span>
<span class="nc" id="L3641">		return result;</span>
	}

	/**
	 * Score this unit with its suitability for pioneering.
	 *
	 * A pioneer must be a colonst. Favour: - existing pioneers especially if on
	 * the map - expert pioneer units - then by skill but not other experts
	 *
	 * @return A pioneering score.
	 */
	public int getPioneerScore() {
<span class="nc bnc" id="L3653" title="All 2 branches missed.">		int ht = (hasTile()) ? 100 : 0;</span>
<span class="nc bnc" id="L3654" title="All 4 branches missed.">		return (getLocation() == null || !isColonist()) ? -1000</span>
<span class="nc bnc" id="L3655" title="All 2 branches missed.">				: (hasAbility(Ability.IMPROVE_TERRAIN)) ? 900 + ht</span>
<span class="nc bnc" id="L3656" title="All 2 branches missed.">						: (hasAbility(Ability.EXPERT_PIONEER)) ? 700</span>
<span class="nc bnc" id="L3657" title="All 2 branches missed.">								: (!hasDefaultRole()) ? 0</span>
<span class="nc bnc" id="L3658" title="All 2 branches missed.">										: (getSkillLevel() &gt; 0) ? 0</span>
<span class="nc" id="L3659">												: 200 + getSkillLevel() * 50;</span>
	}

	/**
	 * Score this unit with its suitability for scouting.
	 *
	 * A scout must be a colonist. Favour: - existing scouts especially if on
	 * the map - expert scouts - lower skill level as scouting is a good career
	 * for crims and servants which might become seasoned scouts
	 *
	 * @return A scouting score.
	 */
	public int getScoutScore() {
<span class="nc bnc" id="L3672" title="All 2 branches missed.">		int ht = (hasTile()) ? 100 : 0;</span>
<span class="nc bnc" id="L3673" title="All 4 branches missed.">		return (getLocation() == null || !isColonist()) ? -1000</span>
<span class="nc bnc" id="L3674" title="All 2 branches missed.">				: (hasAbility(Ability.SPEAK_WITH_CHIEF)) ? 900 + ht</span>
<span class="nc bnc" id="L3675" title="All 2 branches missed.">						: (hasAbility(Ability.EXPERT_SCOUT)) ? 700</span>
<span class="nc bnc" id="L3676" title="All 2 branches missed.">								: (!hasDefaultRole()) ? 0</span>
<span class="nc bnc" id="L3677" title="All 2 branches missed.">										: (getSkillLevel() &lt;= 0) ? -200</span>
<span class="nc" id="L3678">												* getSkillLevel() : 0;</span>
	}

	/**
	 * Evaluate this unit for trade purposes.
	 *
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt; to evaluate for.
	 * @return A value of this unit.
	 */
	public int evaluateFor(Player player) {
<span class="nc" id="L3689">		final Europe europe = player.getEurope();</span>
<span class="nc bnc" id="L3690" title="All 4 branches missed.">		if (player.isAI() &amp;&amp; player.getUnits().size() &lt; 10) {</span>
<span class="nc" id="L3691">			return Integer.MIN_VALUE;</span>
		}
<span class="nc bnc" id="L3693" title="All 2 branches missed.">		return (europe == null) ? 500 : europe.getUnitPrice(getType());</span>
	}

	// @compat 0.11.0
	/**
	 * Get modifiers required for combat.
	 *
	 * This can be replaced with just getModifiers() when accepted
	 * specifications have all combat modifiers with correct index values.
	 *
	 * @param id
	 *            The identifier to get combat modifiers for.
	 * @param fcgot
	 *            An optional &lt;code&gt;FreeColSpecObjectType&lt;/code&gt; the modifier
	 *            applies to.
	 * @param turn
	 *            An optional applicable &lt;code&gt;Turn&lt;/code&gt;.
	 * @return The set of &lt;code&gt;Modifier&lt;/code&gt;s found.
	 */
	public Set&lt;Modifier&gt; getCombatModifiers(String id,
			FreeColSpecObjectType fcgot, Turn turn) {
<span class="nc" id="L3714">		final Player owner = getOwner();</span>
<span class="nc" id="L3715">		final UnitType unitType = getType();</span>
<span class="nc" id="L3716">		Set&lt;Modifier&gt; result = new HashSet&lt;&gt;();</span>

		// UnitType modifiers always apply
<span class="nc bnc" id="L3719" title="All 2 branches missed.">		for (Modifier m : unitType.getModifiers(id, fcgot, turn)) {</span>
<span class="nc bnc" id="L3720" title="All 2 branches missed.">			switch (m.getType()) {</span>
			case ADDITIVE:
<span class="nc" id="L3722">				m.setModifierIndex(Modifier.UNIT_ADDITIVE_COMBAT_INDEX);</span>
<span class="nc" id="L3723">				break;</span>
			default:
<span class="nc" id="L3725">				m.setModifierIndex(Modifier.UNIT_NORMAL_COMBAT_INDEX);</span>
				break;
			}
<span class="nc" id="L3728">			result.add(m);</span>
		}

		// The player's modifiers may not all apply
<span class="nc bnc" id="L3732" title="All 2 branches missed.">		for (Modifier m : owner.getModifiers(id, fcgot, turn)) {</span>
<span class="nc" id="L3733">			m.setModifierIndex(Modifier.GENERAL_COMBAT_INDEX);</span>
<span class="nc" id="L3734">			result.add(m);</span>
		}

		// Role modifiers apply
<span class="nc bnc" id="L3738" title="All 2 branches missed.">		for (Modifier m : role.getModifiers(id, fcgot, turn)) {</span>
<span class="nc" id="L3739">			m.setModifierIndex(Modifier.ROLE_COMBAT_INDEX);</span>
<span class="nc" id="L3740">			result.add(m);</span>
		}

<span class="nc" id="L3743">		return result;</span>
	}

	// end @compat 0.11.0

	// Message unpacking support.

	/**
	 * Gets the tile in a given direction.
	 *
	 * @param directionString
	 *            The direction.
	 * @return The &lt;code&gt;Tile&lt;/code&gt; in the given direction.
	 * @throws IllegalStateException
	 *             if there is trouble.
	 */
	public Tile getNeighbourTile(String directionString) {
<span class="nc bnc" id="L3760" title="All 2 branches missed.">		if (!hasTile()) {</span>
<span class="nc" id="L3761">			throw new IllegalStateException(&quot;Unit is not on the map: &quot;</span>
<span class="nc" id="L3762">					+ getId());</span>
		}

<span class="nc" id="L3765">		Direction direction = Enum.valueOf(Direction.class, directionString);</span>
<span class="nc" id="L3766">		Tile tile = getTile().getNeighbourOrNull(direction);</span>
<span class="nc bnc" id="L3767" title="All 2 branches missed.">		if (tile == null) {</span>
<span class="nc" id="L3768">			throw new IllegalStateException(&quot;Could not find tile&quot;</span>
<span class="nc" id="L3769">					+ &quot; in direction: &quot; + direction + &quot; from unit: &quot; + getId());</span>
		}
<span class="nc" id="L3771">		return tile;</span>
	}

	/**
	 * Get a settlement by identifier, validating as much as possible. Designed
	 * for message unpacking where the identifier should not be trusted.
	 *
	 * @param settlementId
	 *            The identifier of the &lt;code&gt;Settlement&lt;/code&gt; to be found.
	 * @return The settlement corresponding to the settlementId argument.
	 * @throws IllegalStateException
	 *             on failure to validate the settlementId in any way.
	 */
	public Settlement getAdjacentSettlementSafely(String settlementId)
			throws IllegalStateException {
<span class="nc" id="L3786">		Game game = getOwner().getGame();</span>

<span class="nc" id="L3788">		Settlement settlement = game.getFreeColGameObject(settlementId,</span>
<span class="nc" id="L3789">				Settlement.class);</span>
<span class="nc bnc" id="L3790" title="All 2 branches missed.">		if (settlement == null) {</span>
<span class="nc" id="L3791">			throw new IllegalStateException(&quot;Not a settlement: &quot; + settlementId);</span>
<span class="nc bnc" id="L3792" title="All 2 branches missed.">		} else if (settlement.getTile() == null) {</span>
<span class="nc" id="L3793">			throw new IllegalStateException(&quot;Settlement is not on the map: &quot;</span>
<span class="nc" id="L3794">					+ settlementId);</span>
		}

<span class="nc bnc" id="L3797" title="All 2 branches missed.">		if (!hasTile()) {</span>
<span class="nc" id="L3798">			throw new IllegalStateException(&quot;Unit is not on the map: &quot;</span>
<span class="nc" id="L3799">					+ getId());</span>
<span class="nc bnc" id="L3800" title="All 2 branches missed.">		} else if (getTile().getDistanceTo(settlement.getTile()) &gt; 1) {</span>
<span class="nc" id="L3801">			throw new IllegalStateException(&quot;Unit &quot; + getId()</span>
<span class="nc" id="L3802">					+ &quot; is not adjacent to settlement: &quot; + settlementId);</span>
<span class="nc bnc" id="L3803" title="All 2 branches missed.">		} else if (getOwner() == settlement.getOwner()) {</span>
<span class="nc" id="L3804">			throw new IllegalStateException(&quot;Unit: &quot; + getId()</span>
<span class="nc" id="L3805">					+ &quot; and settlement: &quot; + settlementId</span>
<span class="nc" id="L3806">					+ &quot; are both owned by player: &quot; + getOwner().getId());</span>
		}

<span class="nc" id="L3809">		return settlement;</span>
	}

	/**
	 * Get an adjacent Indian settlement by identifier, validating as much as
	 * possible, including checking whether the nation involved has been
	 * contacted. Designed for message unpacking where the identifier should not
	 * be trusted.
	 *
	 * @param id
	 *            The identifier of the &lt;code&gt;IndianSettlement&lt;/code&gt; to be
	 *            found.
	 * @return The settlement corresponding to the settlementId argument.
	 * @throws IllegalStateException
	 *             on failure to validate the settlementId in any way.
	 */
	public IndianSettlement getAdjacentIndianSettlementSafely(String id)
			throws IllegalStateException {
<span class="nc" id="L3827">		Settlement settlement = getAdjacentSettlementSafely(id);</span>
<span class="nc bnc" id="L3828" title="All 2 branches missed.">		if (!(settlement instanceof IndianSettlement)) {</span>
<span class="nc" id="L3829">			throw new IllegalStateException(&quot;Not an indianSettlement: &quot; + id);</span>
<span class="nc bnc" id="L3830" title="All 2 branches missed.">		} else if (!getOwner().hasContacted(settlement.getOwner())) {</span>
<span class="nc" id="L3831">			throw new IllegalStateException(&quot;Player has not contacted the &quot;</span>
<span class="nc" id="L3832">					+ settlement.getOwner().getNation());</span>
		}

<span class="nc" id="L3835">		return (IndianSettlement) settlement;</span>
	}

	// Interface Consumer

	/**
	 * {@inheritDoc}
	 */
	@Override
	public List&lt;AbstractGoods&gt; getConsumedGoods() {
<span class="nc" id="L3845">		return unitType.getConsumedGoods();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int getPriority() {
<span class="nc" id="L3853">		return unitType.getPriority();</span>
	}

	// Interface Ownable

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Player getOwner() {
<span class="nc" id="L3863">		return owner;</span>
	}

	/**
	 * {@inheritDoc}
	 *
	 * -vis: This routine has visibility implications.
	 */
	@Override
	public void setOwner(Player player) {
<span class="nc" id="L3873">		this.owner = player;</span>
<span class="nc" id="L3874">	}</span>

	// Interface Locatable
	// getTile and getSpaceTaken are shared with Location below

	/**
	 * Gets the location of this unit.
	 *
	 * @return The location of this &lt;code&gt;Unit&lt;/code&gt;.
	 */
	@Override
	public Location getLocation() {
<span class="nc" id="L3886">		return this.location;</span>
	}

	/**
	 * Sets the location of this unit.
	 *
	 * -vis: This routine changes player visibility. -til: While units do not
	 * contribute to tile appearance as such, if they move in/out of a colony
	 * the visible colony size changes.
	 *
	 * @param newLocation
	 *            The new &lt;code&gt;Location&lt;/code&gt;.
	 * @return True if the location change succeeds.
	 */
	@Override
	public boolean setLocation(Location newLocation) {
		// It is possible to add a unit to a non-specific location
		// within a colony by specifying the colony as the new
		// location. Colony.joinColony handles this special case.
<span class="nc bnc" id="L3905" title="All 2 branches missed.">		if (newLocation instanceof Colony) {</span>
<span class="nc" id="L3906">			return ((Colony) newLocation).joinColony(this);</span>
		}

<span class="nc bnc" id="L3909" title="All 2 branches missed.">		if (newLocation == this.location)</span>
<span class="nc" id="L3910">			return true;</span>
<span class="nc bnc" id="L3911" title="All 4 branches missed.">		if (newLocation != null &amp;&amp; !newLocation.canAdd(this)) {</span>
<span class="nc" id="L3912">			logger.warning(&quot;Can not add &quot; + this + &quot; to &quot; + newLocation.getId());</span>
<span class="nc" id="L3913">			return false;</span>
		}

		// If the unit either starts or ends this move in a colony
		// then teaching status can change. However, if it moves
		// between locations within the same colony with the same
		// teaching ability, the teaching state should *not* change.
		// We have to handle this issue here in setLocation as this is
		// the only place that contains information about both
		// locations.
<span class="nc bnc" id="L3923" title="All 2 branches missed.">		Colony oldColony = (isInColony()) ? this.location.getColony() : null;</span>
<span class="nc bnc" id="L3924" title="All 2 branches missed.">		Colony newColony = (newLocation instanceof WorkLocation) ? newLocation</span>
<span class="nc" id="L3925">				.getColony() : null;</span>
<span class="nc bnc" id="L3926" title="All 4 branches missed.">		boolean withinColony = newColony != null &amp;&amp; newColony == oldColony;</span>
<span class="nc bnc" id="L3927" title="All 2 branches missed.">		boolean preserveEducation = withinColony</span>
<span class="nc" id="L3928">				&amp;&amp; (((WorkLocation) this.location).canTeach() == ((WorkLocation) newLocation)</span>
<span class="nc bnc" id="L3929" title="All 2 branches missed.">						.canTeach());</span>

		// First disable education that will fail due to the move.
<span class="nc bnc" id="L3932" title="All 4 branches missed.">		if (oldColony != null &amp;&amp; !preserveEducation) {</span>
<span class="nc" id="L3933">			oldColony.updateEducation(this, false);</span>
		}

		// Move out of the old location.
<span class="nc bnc" id="L3937" title="All 2 branches missed.">		if (this.location == null) {</span>
			; // do nothing
<span class="nc bnc" id="L3939" title="All 2 branches missed.">		} else if (!this.location.remove(this)) {// -vis</span>
			// &quot;Should not happen&quot; (should always be able to remove)
<span class="nc" id="L3941">			throw new RuntimeException(&quot;Failed to remove &quot; + this + &quot; from &quot;</span>
<span class="nc" id="L3942">					+ this.location.getId());</span>
		}

		// Move in to the new location.
<span class="nc bnc" id="L3946" title="All 2 branches missed.">		if (newLocation == null) {</span>
<span class="nc" id="L3947">			setLocationNoUpdate(null);// -vis</span>
<span class="nc bnc" id="L3948" title="All 2 branches missed.">		} else if (!newLocation.add(this)) {// -vis</span>
			// &quot;Should not happen&quot; (canAdd was checked above)
<span class="nc" id="L3950">			throw new RuntimeException(&quot;Failed to add &quot; + this + &quot; to &quot;</span>
<span class="nc" id="L3951">					+ newLocation.getId());</span>
		}

		// See if education needs to be re-enabled.
<span class="nc bnc" id="L3955" title="All 4 branches missed.">		if (newColony != null &amp;&amp; !preserveEducation) {</span>
<span class="nc" id="L3956">			newColony.updateEducation(this, true);</span>
		}

		// Update population of any colonies involved.
<span class="nc bnc" id="L3960" title="All 2 branches missed.">		if (!withinColony) {</span>
<span class="nc bnc" id="L3961" title="All 2 branches missed.">			if (oldColony != null)</span>
<span class="nc" id="L3962">				oldColony.updatePopulation();</span>
<span class="nc bnc" id="L3963" title="All 2 branches missed.">			if (newColony != null)</span>
<span class="nc" id="L3964">				newColony.updatePopulation();</span>
		}
<span class="nc" id="L3966">		return true;</span>
	}

	/**
	 * Checks if this &lt;code&gt;Unit&lt;/code&gt; is located in Europe. That is; either
	 * directly or onboard a carrier which is in Europe.
	 *
	 * @return True if in &lt;code&gt;Europe&lt;/code&gt;.
	 */
	@Override
	public boolean isInEurope() {
<span class="nc bnc" id="L3977" title="All 2 branches missed.">		return (isOnCarrier()) ? getCarrier().isInEurope()</span>
<span class="nc" id="L3978">				: getLocation() instanceof Europe;</span>
	}

	// Interface Location (from GoodsLocation via UnitLocation)
	// Inherits
	// FreeColObject.getId
	// UnitLocation.getLocationLabelFor
	// UnitLocation.contains
	// UnitLocation.canAdd
	// UnitLocation.getUnitCount
	// UnitLocation.getUnitList
	// GoodsLocation.getGoodsContainer

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Tile getTile() {
<span class="nc bnc" id="L3996" title="All 2 branches missed.">		return (getLocation() != null) ? getLocation().getTile() : null;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public StringTemplate getLocationLabel() {
<span class="nc" id="L4004">		return StringTemplate.template(&quot;model.unit.onBoard&quot;).addStringTemplate(</span>
<span class="nc" id="L4005">				&quot;%unit%&quot;, this.getLabel());</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean add(Locatable locatable) {
<span class="nc bnc" id="L4013" title="All 2 branches missed.">		if (!canAdd(locatable)) {</span>
<span class="nc" id="L4014">			return false;</span>
<span class="nc bnc" id="L4015" title="All 2 branches missed.">		} else if (locatable instanceof Unit) {</span>
<span class="nc" id="L4016">			Unit unit = (Unit) locatable;</span>
<span class="nc bnc" id="L4017" title="All 2 branches missed.">			if (super.add(locatable)) {</span>
				// FIXME: there seems to be an inconsistency between
				// units moving from an adjacent tile onto a ship and
				// units boarding a ship in-colony. The former does not
				// appear to come through here (which it probably should)
				// as the ship's moves do not get zeroed.
<span class="nc" id="L4023">				spendAllMoves();</span>
<span class="nc" id="L4024">				unit.setState(UnitState.SENTRY);</span>
<span class="nc" id="L4025">				return true;</span>
			}
<span class="nc bnc" id="L4027" title="All 2 branches missed.">		} else if (locatable instanceof Goods) {</span>
<span class="nc" id="L4028">			Goods goods = (Goods) locatable;</span>
<span class="nc bnc" id="L4029" title="All 2 branches missed.">			if (super.addGoods(goods)) {</span>
<span class="nc" id="L4030">				spendAllMoves();</span>
<span class="nc" id="L4031">				return true;</span>
			}
		} else {
<span class="nc" id="L4034">			throw new IllegalStateException(&quot;Can not be added to unit: &quot;</span>
<span class="nc" id="L4035">					+ locatable);</span>
		}
<span class="nc" id="L4037">		return false;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean remove(Locatable locatable) {
<span class="nc bnc" id="L4045" title="All 2 branches missed.">		if (locatable == null) {</span>
<span class="nc" id="L4046">			throw new IllegalArgumentException(&quot;Locatable must not be 'null'.&quot;);</span>
<span class="nc bnc" id="L4047" title="All 4 branches missed.">		} else if (locatable instanceof Unit &amp;&amp; canCarryUnits()) {</span>
<span class="nc bnc" id="L4048" title="All 2 branches missed.">			if (super.remove(locatable)) {</span>
<span class="nc" id="L4049">				spendAllMoves();</span>
<span class="nc" id="L4050">				return true;</span>
			}
<span class="nc bnc" id="L4052" title="All 4 branches missed.">		} else if (locatable instanceof Goods &amp;&amp; canCarryGoods()) {</span>
<span class="nc bnc" id="L4053" title="All 2 branches missed.">			if (super.removeGoods((Goods) locatable) != null) {</span>
<span class="nc" id="L4054">				spendAllMoves();</span>
<span class="nc" id="L4055">				return true;</span>
			}
		} else {
<span class="nc" id="L4058">			logger.warning(&quot;Tried to remove from unit: &quot; + locatable);</span>
		}
<span class="nc" id="L4060">		return false;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Settlement getSettlement() {
<span class="nc" id="L4068">		Location loc = getLocation();</span>
<span class="nc bnc" id="L4069" title="All 2 branches missed.">		return (loc != null) ? loc.getSettlement() : null;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Location up() {
<span class="nc bnc" id="L4077" title="All 2 branches missed.">		return (isInEurope()) ? getLocation().up()</span>
<span class="nc bnc" id="L4078" title="All 4 branches missed.">				: (isInColony()) ? getColony() : (hasTile()) ? getTile().up()</span>
<span class="nc" id="L4079">						: this;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int getRank() {
<span class="nc" id="L4087">		return Location.getRank(getLocation());</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String toShortString() {
<span class="nc" id="L4095">		StringBuilder sb = new StringBuilder(32);</span>
<span class="nc" id="L4096">		sb.append(getId()).append(&quot;-&quot;).append(getType().getSuffix());</span>
<span class="nc bnc" id="L4097" title="All 2 branches missed.">		if (!hasDefaultRole()) {</span>
<span class="nc" id="L4098">			sb.append(&quot;-&quot;).append(getRoleSuffix());</span>
<span class="nc" id="L4099">			int count = getRoleCount();</span>
<span class="nc bnc" id="L4100" title="All 2 branches missed.">			if (count &gt; 1)</span>
<span class="nc" id="L4101">				sb.append(&quot;.&quot;).append(count);</span>
		}
<span class="nc" id="L4103">		return sb.toString();</span>
	}

	// UnitLocation
	// Inherits
	// UnitLocation.getSpaceTaken
	// UnitLocation.moveToFront
	// UnitLocation.clearUnitList

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int getSpaceTaken() {
		// We do not have to consider what this unit is carrying
		// because carriers can not be put onto carriers. Yet.
<span class="nc" id="L4119">		return unitType.getSpaceTaken();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public NoAddReason getNoAddReason(Locatable locatable) {
<span class="nc bnc" id="L4127" title="All 2 branches missed.">		if (locatable == this) {</span>
<span class="nc" id="L4128">			return NoAddReason.ALREADY_PRESENT;</span>
<span class="nc bnc" id="L4129" title="All 2 branches missed.">		} else if (locatable instanceof Unit) {</span>
<span class="nc bnc" id="L4130" title="All 2 branches missed.">			return (!canCarryUnits()) ? NoAddReason.WRONG_TYPE</span>
<span class="nc bnc" id="L4131" title="All 2 branches missed.">					: (locatable.getSpaceTaken() &gt; getSpaceLeft()) ? NoAddReason.CAPACITY_EXCEEDED</span>
<span class="nc" id="L4132">							: super.getNoAddReason(locatable);</span>
<span class="nc bnc" id="L4133" title="All 2 branches missed.">		} else if (locatable instanceof Goods) {</span>
<span class="nc" id="L4134">			Goods goods = (Goods) locatable;</span>
<span class="nc bnc" id="L4135" title="All 2 branches missed.">			return (!canCarryGoods()) ? NoAddReason.WRONG_TYPE</span>
<span class="nc bnc" id="L4136" title="All 2 branches missed.">					: (goods.getAmount() &gt; getLoadableAmount(goods.getType())) ? NoAddReason.CAPACITY_EXCEEDED</span>
<span class="nc" id="L4137">							: NoAddReason.NONE;</span>
			// Do not call super.getNoAddReason for goods because
			// the capacity test in GoodsLocation.getNoAddReason does not
			// account for packing and is thus too conservative.
		}
<span class="nc" id="L4142">		return super.getNoAddReason(locatable);</span>
	}

	// GoodsLocation
	// Inherits
	// GoodsLocation.addGoods
	// GoodsLocation.removeGoods

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int getGoodsCapacity() {
<span class="nc" id="L4155">		return getCargoCapacity();</span>
	}

	// Override FreeColGameObject

	/**
	 * {@inheritDoc}
	 *
	 * -vis: This routine can change player visibility.
	 */
	@Override
	public void disposeResources() {
<span class="nc" id="L4167">		Location loc = getLocation();</span>
<span class="nc bnc" id="L4168" title="All 2 branches missed.">		if (loc != null) {</span>
<span class="nc" id="L4169">			loc.remove(this);</span>
			// Do not set location to null, units that are slaughtered in
			// battle need to remain valid during the animation.
		}

<span class="nc bnc" id="L4174" title="All 2 branches missed.">		if (teacher != null) {</span>
<span class="nc" id="L4175">			teacher.setStudent(null);</span>
<span class="nc" id="L4176">			teacher = null;</span>
		}

<span class="nc bnc" id="L4179" title="All 2 branches missed.">		if (student != null) {</span>
<span class="nc" id="L4180">			student.setTeacher(null);</span>
<span class="nc" id="L4181">			student = null;</span>
		}

<span class="nc" id="L4184">		setHomeIndianSettlement(null);</span>

<span class="nc" id="L4186">		getOwner().removeUnit(this);</span>

<span class="nc" id="L4188">		super.disposeResources();</span>
<span class="nc" id="L4189">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public FreeColGameObject getLinkTarget(Player player) {
<span class="nc bnc" id="L4196" title="All 2 branches missed.">		return (hasTile()) ? (FreeColGameObject) getTile().up() : player</span>
<span class="nc" id="L4197">				.getEurope();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int checkIntegrity(boolean fix) {
<span class="nc" id="L4205">		int result = super.checkIntegrity(fix);</span>
<span class="nc bnc" id="L4206" title="All 2 branches missed.">		if (this.role == null) {</span>
<span class="nc bnc" id="L4207" title="All 2 branches missed.">			if (fix) {</span>
<span class="nc" id="L4208">				this.role = getSpecification().getDefaultRole();</span>
<span class="nc" id="L4209">				logger.warning(&quot;Fixed missing role for: &quot; + getId());</span>
<span class="nc" id="L4210">				result = 0;</span>
<span class="nc" id="L4211">			} else {</span>
<span class="nc" id="L4212">				logger.warning(&quot;Missing role for: &quot; + getId());</span>
<span class="nc" id="L4213">				result = -1;</span>
			}
		}
<span class="nc bnc" id="L4216" title="All 2 branches missed.">		if (this.destination != null) {</span>
<span class="nc bnc" id="L4217" title="All 2 branches missed.">			if (!((FreeColGameObject) this.destination).isInitialized()) {</span>
<span class="nc bnc" id="L4218" title="All 2 branches missed.">				if (fix) {</span>
<span class="nc" id="L4219">					this.destination = null;</span>
<span class="nc" id="L4220">					logger.warning(&quot;Cleared uninitialized destination for: &quot;</span>
<span class="nc" id="L4221">							+ getId());</span>
<span class="nc" id="L4222">					result = Math.min(result, 0);</span>
<span class="nc" id="L4223">				} else {</span>
<span class="nc" id="L4224">					logger.warning(&quot;Uninitialized destination for: &quot; + getId());</span>
<span class="nc" id="L4225">					result = -1;</span>
				}
			}
		}
<span class="nc bnc" id="L4229" title="All 4 branches missed.">		if (this.state == UnitState.IMPROVING &amp;&amp; this.workImprovement == null) {</span>
			// This can happen as a result of trying to read an invalid
			// improvement.
<span class="nc bnc" id="L4232" title="All 2 branches missed.">			if (fix) {</span>
<span class="nc" id="L4233">				this.state = UnitState.ACTIVE;</span>
<span class="nc" id="L4234">				logger.warning(&quot;Made improving unit active: &quot; + getId());</span>
<span class="nc" id="L4235">				result = Math.min(result, 0);</span>
<span class="nc" id="L4236">			} else {</span>
<span class="nc" id="L4237">				logger.warning(&quot;Improving unit with no improvement: &quot; + getId());</span>
<span class="nc" id="L4238">				result = -1;</span>
			}
		}
<span class="nc" id="L4241">		return result;</span>
	}

	// Override FreeColObject

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Set&lt;Ability&gt; getAbilities(String id, FreeColSpecObjectType fcgot,
			Turn turn) {
<span class="nc" id="L4252">		final Player owner = getOwner();</span>
<span class="nc" id="L4253">		final UnitType unitType = getType();</span>
<span class="nc" id="L4254">		Set&lt;Ability&gt; result = new HashSet&lt;&gt;();</span>

		// UnitType abilities always apply.
<span class="nc" id="L4257">		result.addAll(unitType.getAbilities(id));</span>

		// Roles apply with qualification.
<span class="nc" id="L4260">		result.addAll(role.getAbilities(id, fcgot, turn));</span>

		// The player's abilities require more qualification.
<span class="nc" id="L4263">		result.addAll(owner.getAbilities(id, fcgot, turn));</span>

		// Location abilities may apply.
		// FIXME: extend this to all locations? May simplify
		// code. Units are also Locations however, which complicates
		// the issue as we do not want Units aboard other Units to share
		// the abilities of the carriers.
<span class="nc bnc" id="L4270" title="All 2 branches missed.">		if (getSettlement() != null) {</span>
<span class="nc" id="L4271">			result.addAll(getSettlement().getAbilities(id, unitType, turn));</span>
<span class="nc bnc" id="L4272" title="All 2 branches missed.">		} else if (isInEurope()) {</span>
			// @compat 0.10.x
			// It makes sense here to do:
			// Europe europe = owner.getEurope();
			// However while there is fixup code in readChildren that calls
			// this routine we can not rely on owner.europe being initialized
			// yet. Hence the following:
<span class="nc" id="L4279">			Location loc = getLocation();</span>
<span class="nc bnc" id="L4280" title="All 2 branches missed.">			Europe europe = (loc instanceof Europe) ? (Europe) loc</span>
<span class="nc bnc" id="L4281" title="All 2 branches missed.">					: (loc instanceof Unit) ? (Europe) ((Unit) loc)</span>
<span class="nc" id="L4282">							.getLocation() : null;</span>
			// end @compat 0.10.x
<span class="nc bnc" id="L4284" title="All 2 branches missed.">			if (getAbilities(id, unitType, turn) != null) {</span>
<span class="nc" id="L4285">				result.addAll(europe.getAbilities(id, unitType, turn));</span>
			}
		}
<span class="nc" id="L4288">		return result;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Set&lt;Modifier&gt; getModifiers(String id, FreeColSpecObjectType fcgot,
			Turn turn) {
<span class="nc" id="L4297">		final Player owner = getOwner();</span>
<span class="nc" id="L4298">		final UnitType unitType = getType();</span>
<span class="nc" id="L4299">		Set&lt;Modifier&gt; result = new HashSet&lt;&gt;();</span>

		// UnitType modifiers always apply
<span class="nc" id="L4302">		result.addAll(unitType.getModifiers(id, fcgot, turn));</span>

		// The player's modifiers may not all apply
<span class="nc" id="L4305">		result.addAll(owner.getModifiers(id, fcgot, turn));</span>

		// Role modifiers apply
<span class="nc" id="L4308">		result.addAll(role.getModifiers(id, fcgot, turn));</span>

<span class="nc" id="L4310">		return result;</span>
	}

	// Serialization

	private static final String ATTRITION_TAG = &quot;attrition&quot;;
	private static final String COUNT_TAG = &quot;count&quot;;
	private static final String CURRENT_STOP_TAG = &quot;currentStop&quot;;
	private static final String DESTINATION_TAG = &quot;destination&quot;;
	private static final String ENTRY_LOCATION_TAG = &quot;entryLocation&quot;;
	private static final String ETHNICITY_TAG = &quot;ethnicity&quot;;
	private static final String EXPERIENCE_TAG = &quot;experience&quot;;
	private static final String EXPERIENCE_TYPE_TAG = &quot;experienceType&quot;;
	private static final String HIT_POINTS_TAG = &quot;hitPoints&quot;;
	private static final String INDIAN_SETTLEMENT_TAG = &quot;indianSettlement&quot;;
	private static final String LOCATION_TAG = &quot;location&quot;;
	private static final String MOVES_LEFT_TAG = &quot;movesLeft&quot;;
	private static final String NAME_TAG = &quot;name&quot;;
	private static final String NATIONALITY_TAG = &quot;nationality&quot;;
	private static final String OWNER_TAG = &quot;owner&quot;;
	private static final String ROLE_TAG = &quot;role&quot;;
	private static final String ROLE_COUNT_TAG = &quot;roleCount&quot;;
	private static final String STATE_TAG = &quot;state&quot;;
	private static final String STUDENT_TAG = &quot;student&quot;;
	private static final String TRADE_ROUTE_TAG = &quot;tradeRoute&quot;;
	private static final String TEACHER_TAG = &quot;teacher&quot;;
	private static final String TREASURE_AMOUNT_TAG = &quot;treasureAmount&quot;;
	private static final String TURNS_OF_TRAINING_TAG = &quot;turnsOfTraining&quot;;
	private static final String UNIT_TYPE_TAG = &quot;unitType&quot;;
	private static final String VISIBLE_GOODS_COUNT_TAG = &quot;visibleGoodsCount&quot;;
	private static final String WORK_LEFT_TAG = &quot;workLeft&quot;;
	private static final String WORK_TYPE_TAG = &quot;workType&quot;;
	// @compat 0.10.5
	private static final String OLD_UNITS_TAG = &quot;units&quot;;
	// end @compat
	// @compat 0.10.7
	private static final String OLD_HIT_POINTS_TAG = &quot;hitpoints&quot;;
	private static final String EQUIPMENT_TAG = &quot;equipment&quot;;
	/** The equipment this Unit carries. Now subsumed into roles. */
<span class="nc" id="L4349">	private final TypeCountMap&lt;EquipmentType&gt; equipment = new TypeCountMap&lt;&gt;();</span>
	// end @compat 0.10.x
	// @compat 0.11.3
<span class="fc" id="L4352">	private static final String OLD_TILE_IMPROVEMENT_TAG = &quot;tileimprovement&quot;;</span>

	// end @compat 0.11.3

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void writeAttributes(FreeColXMLWriter xw)
			throws XMLStreamException {
<span class="nc" id="L4362">		super.writeAttributes(xw);</span>

<span class="nc" id="L4364">		boolean full = xw.validFor(getOwner());</span>

<span class="nc bnc" id="L4366" title="All 2 branches missed.">		if (name != null)</span>
<span class="nc" id="L4367">			xw.writeAttribute(NAME_TAG, name);</span>

<span class="nc" id="L4369">		xw.writeAttribute(UNIT_TYPE_TAG, unitType);</span>

<span class="nc" id="L4371">		xw.writeAttribute(MOVES_LEFT_TAG, movesLeft);</span>

<span class="nc" id="L4373">		xw.writeAttribute(STATE_TAG, state);</span>

<span class="nc" id="L4375">		xw.writeAttribute(ROLE_TAG, role);</span>

<span class="nc" id="L4377">		xw.writeAttribute(ROLE_COUNT_TAG, roleCount);</span>

<span class="nc bnc" id="L4379" title="All 4 branches missed.">		if (!full &amp;&amp; hasAbility(Ability.PIRACY)) {</span>
			// Pirates do not disclose national characteristics.
<span class="nc" id="L4381">			xw.writeAttribute(OWNER_TAG, getGame().getUnknownEnemy());</span>

<span class="nc" id="L4383">		} else {</span>
<span class="nc" id="L4384">			xw.writeAttribute(OWNER_TAG, getOwner());</span>

<span class="nc bnc" id="L4386" title="All 2 branches missed.">			if (isPerson()) {</span>
				// Do not write out nationality and ethnicity for non-persons.
<span class="nc" id="L4388">				xw.writeAttribute(NATIONALITY_TAG,</span>
<span class="nc bnc" id="L4389" title="All 2 branches missed.">						(nationality != null) ? nationality : getOwner()</span>
<span class="nc" id="L4390">								.getNationId());</span>

<span class="nc" id="L4392">				xw.writeAttribute(ETHNICITY_TAG,</span>
<span class="nc bnc" id="L4393" title="All 2 branches missed.">						(ethnicity != null) ? ethnicity : getOwner()</span>
<span class="nc" id="L4394">								.getNationId());</span>
			}
		}

<span class="nc bnc" id="L4398" title="All 2 branches missed.">		if (location != null) {</span>
<span class="nc" id="L4399">			xw.writeLocationAttribute(LOCATION_TAG, location);</span>
		}

<span class="nc" id="L4402">		xw.writeAttribute(TREASURE_AMOUNT_TAG, treasureAmount);</span>

<span class="nc bnc" id="L4404" title="All 2 branches missed.">		if (full) {</span>
<span class="nc bnc" id="L4405" title="All 2 branches missed.">			if (entryLocation != null) {</span>
<span class="nc" id="L4406">				xw.writeLocationAttribute(ENTRY_LOCATION_TAG, entryLocation);</span>
			}

<span class="nc" id="L4409">			xw.writeAttribute(TURNS_OF_TRAINING_TAG, turnsOfTraining);</span>

<span class="nc bnc" id="L4411" title="All 2 branches missed.">			if (workType != null)</span>
<span class="nc" id="L4412">				xw.writeAttribute(WORK_TYPE_TAG, workType);</span>

<span class="nc bnc" id="L4414" title="All 2 branches missed.">			if (experienceType != null) {</span>
<span class="nc" id="L4415">				xw.writeAttribute(EXPERIENCE_TYPE_TAG, experienceType);</span>
			}

<span class="nc" id="L4418">			xw.writeAttribute(EXPERIENCE_TAG, experience);</span>

<span class="nc" id="L4420">			xw.writeAttribute(INDIAN_SETTLEMENT_TAG, indianSettlement);</span>

<span class="nc" id="L4422">			xw.writeAttribute(WORK_LEFT_TAG, workLeft);</span>

<span class="nc" id="L4424">			xw.writeAttribute(HIT_POINTS_TAG, hitPoints);</span>

<span class="nc" id="L4426">			xw.writeAttribute(ATTRITION_TAG, attrition);</span>

<span class="nc bnc" id="L4428" title="All 2 branches missed.">			if (student != null)</span>
<span class="nc" id="L4429">				xw.writeAttribute(STUDENT_TAG, student);</span>

<span class="nc bnc" id="L4431" title="All 2 branches missed.">			if (teacher != null)</span>
<span class="nc" id="L4432">				xw.writeAttribute(TEACHER_TAG, teacher);</span>

<span class="nc bnc" id="L4434" title="All 2 branches missed.">			if (destination != null) {</span>
<span class="nc" id="L4435">				xw.writeLocationAttribute(DESTINATION_TAG, destination);</span>
			}

<span class="nc bnc" id="L4438" title="All 2 branches missed.">			if (tradeRoute != null) {</span>
<span class="nc" id="L4439">				xw.writeAttribute(TRADE_ROUTE_TAG, tradeRoute);</span>

<span class="nc" id="L4441">				xw.writeAttribute(CURRENT_STOP_TAG, currentStop);</span>
			}
		}
<span class="nc" id="L4444">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void writeChildren(FreeColXMLWriter xw) throws XMLStreamException {
<span class="nc bnc" id="L4451" title="All 2 branches missed.">		if (xw.validFor(getOwner())) {</span>

			// Do not show goods or units carried by this unit.
<span class="nc" id="L4454">			super.writeChildren(xw);</span>

<span class="nc bnc" id="L4456" title="All 2 branches missed.">			if (workImprovement != null)</span>
<span class="nc" id="L4457">				workImprovement.toXML(xw);</span>

<span class="nc bnc" id="L4459" title="All 2 branches missed.">		} else if (getType().canCarryGoods()) {</span>
<span class="nc" id="L4460">			xw.writeAttribute(VISIBLE_GOODS_COUNT_TAG, getVisibleGoodsCount());</span>
		}
<span class="nc" id="L4462">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void readAttributes(FreeColXMLReader xr)
			throws XMLStreamException {
<span class="nc" id="L4470">		super.readAttributes(xr);</span>

<span class="nc" id="L4472">		final Specification spec = getSpecification();</span>
<span class="nc" id="L4473">		final Game game = getGame();</span>

<span class="nc" id="L4475">		name = xr.getAttribute(NAME_TAG, (String) null);</span>

<span class="nc" id="L4477">		Player oldOwner = owner;</span>
<span class="nc" id="L4478">		owner = xr.findFreeColGameObject(game, OWNER_TAG, Player.class,</span>
<span class="nc" id="L4479">				(Player) null, true);</span>
<span class="nc bnc" id="L4480" title="All 2 branches missed.">		if (xr.shouldIntern())</span>
<span class="nc" id="L4481">			game.checkOwners(this, oldOwner);</span>

<span class="nc" id="L4483">		unitType = xr.getType(spec, UNIT_TYPE_TAG, UnitType.class,</span>
<span class="nc" id="L4484">				(UnitType) null);</span>

<span class="nc" id="L4486">		state = xr.getAttribute(STATE_TAG, UnitState.class, UnitState.ACTIVE);</span>

<span class="nc" id="L4488">		role = xr.getRole(spec, ROLE_TAG, Role.class, spec.getDefaultRole());</span>
		// @compat 0.10.x
		// Fix roles
<span class="nc bnc" id="L4491" title="All 2 branches missed.">		if (owner.isIndian()) {</span>
<span class="nc bnc" id="L4492" title="All 2 branches missed.">			if (&quot;model.role.scout&quot;.equals(role.getId())) {</span>
<span class="nc" id="L4493">				role = spec.getRole(&quot;model.role.mountedBrave&quot;);</span>
<span class="nc bnc" id="L4494" title="All 2 branches missed.">			} else if (&quot;model.role.soldier&quot;.equals(role.getId())) {</span>
<span class="nc" id="L4495">				role = spec.getRole(&quot;model.role.armedBrave&quot;);</span>
<span class="nc bnc" id="L4496" title="All 2 branches missed.">			} else if (&quot;model.role.dragoon&quot;.equals(role.getId())) {</span>
<span class="nc" id="L4497">				role = spec.getRole(&quot;model.role.nativeDragoon&quot;);</span>
			}
<span class="nc bnc" id="L4499" title="All 2 branches missed.">		} else if (owner.isREF()) {</span>
<span class="nc bnc" id="L4500" title="All 2 branches missed.">			if (&quot;model.role.soldier&quot;.equals(role.getId())</span>
<span class="nc bnc" id="L4501" title="All 2 branches missed.">					&amp;&amp; unitType.hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4502">				role = spec.getRole(&quot;model.role.infantry&quot;);</span>
<span class="nc bnc" id="L4503" title="All 2 branches missed.">			} else if (&quot;model.role.dragoon&quot;.equals(role.getId())</span>
<span class="nc bnc" id="L4504" title="All 2 branches missed.">					&amp;&amp; unitType.hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4505">				role = spec.getRole(&quot;model.role.cavalry&quot;);</span>
<span class="nc bnc" id="L4506" title="All 2 branches missed.">			} else if (&quot;model.role.infantry&quot;.equals(role.getId())</span>
<span class="nc bnc" id="L4507" title="All 2 branches missed.">					&amp;&amp; !unitType.hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4508">				role = spec.getRole(&quot;model.role.soldier&quot;);</span>
<span class="nc bnc" id="L4509" title="All 2 branches missed.">			} else if (&quot;model.role.cavalry&quot;.equals(role.getId())</span>
<span class="nc bnc" id="L4510" title="All 2 branches missed.">					&amp;&amp; !unitType.hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4511">				role = spec.getRole(&quot;model.role.dragoon&quot;);</span>
			}
<span class="nc" id="L4513">		} else {</span>
<span class="nc bnc" id="L4514" title="All 2 branches missed.">			if (&quot;model.role.infantry&quot;.equals(role.getId())) {</span>
<span class="nc" id="L4515">				role = spec.getRole(&quot;model.role.soldier&quot;);</span>
<span class="nc bnc" id="L4516" title="All 2 branches missed.">			} else if (&quot;model.role.cavalry&quot;.equals(role.getId())) {</span>
<span class="nc" id="L4517">				role = spec.getRole(&quot;model.role.dragoon&quot;);</span>
			}
		}
		// end @compat 0.10.x

<span class="nc" id="L4522">		roleCount = xr.getAttribute(ROLE_COUNT_TAG,</span>
		// @compat 0.10.x
<span class="nc" id="L4524">				-1</span>
		// Should be role.getMaximumCount()
		// end @compat 0.10.x
				);

<span class="nc" id="L4529">		setLocationNoUpdate(xr.getLocationAttribute(game, LOCATION_TAG, true));</span>

<span class="nc" id="L4531">		entryLocation = xr.getLocationAttribute(game, ENTRY_LOCATION_TAG, true);</span>

<span class="nc" id="L4533">		movesLeft = xr.getAttribute(MOVES_LEFT_TAG, 0);</span>

<span class="nc" id="L4535">		workLeft = xr.getAttribute(WORK_LEFT_TAG, 0);</span>

<span class="nc" id="L4537">		attrition = xr.getAttribute(ATTRITION_TAG, 0);</span>

<span class="nc" id="L4539">		nationality = xr.getAttribute(NATIONALITY_TAG, (String) null);</span>

<span class="nc" id="L4541">		ethnicity = xr.getAttribute(ETHNICITY_TAG, (String) null);</span>

<span class="nc" id="L4543">		turnsOfTraining = xr.getAttribute(TURNS_OF_TRAINING_TAG, 0);</span>

<span class="nc" id="L4545">		hitPoints = xr.getAttribute(HIT_POINTS_TAG, -1);</span>
		// @compat 0.10.7
<span class="nc bnc" id="L4547" title="All 2 branches missed.">		if (hitPoints &lt; 0)</span>
<span class="nc" id="L4548">			hitPoints = xr.getAttribute(OLD_HIT_POINTS_TAG, -1);</span>
		// end @compat

<span class="nc" id="L4551">		teacher = xr</span>
<span class="nc" id="L4552">				.makeFreeColGameObject(game, TEACHER_TAG, Unit.class, false);</span>

<span class="nc" id="L4554">		student = xr</span>
<span class="nc" id="L4555">				.makeFreeColGameObject(game, STUDENT_TAG, Unit.class, false);</span>

<span class="nc" id="L4557">		setHomeIndianSettlement(xr.makeFreeColGameObject(game,</span>
<span class="nc" id="L4558">				INDIAN_SETTLEMENT_TAG, IndianSettlement.class, false));</span>

<span class="nc" id="L4560">		treasureAmount = xr.getAttribute(TREASURE_AMOUNT_TAG, 0);</span>

<span class="nc" id="L4562">		destination = xr.getLocationAttribute(game, DESTINATION_TAG, true);</span>

<span class="nc" id="L4564">		tradeRoute = xr.findFreeColGameObject(game, TRADE_ROUTE_TAG,</span>
<span class="nc" id="L4565">				TradeRoute.class, (TradeRoute) null, false);</span>

<span class="nc bnc" id="L4567" title="All 2 branches missed.">		currentStop = (tradeRoute == null) ? -1 : xr.getAttribute(</span>
<span class="nc" id="L4568">				CURRENT_STOP_TAG, 0);</span>

<span class="nc" id="L4570">		experienceType = xr.getType(spec, EXPERIENCE_TYPE_TAG, GoodsType.class,</span>
<span class="nc" id="L4571">				(GoodsType) null);</span>
<span class="nc bnc" id="L4572" title="All 4 branches missed.">		if (experienceType == null &amp;&amp; workType != null) {</span>
<span class="nc" id="L4573">			experienceType = workType;</span>
		}

<span class="nc" id="L4576">		experience = xr.getAttribute(EXPERIENCE_TAG, 0);</span>

<span class="nc" id="L4578">		visibleGoodsCount = xr.getAttribute(VISIBLE_GOODS_COUNT_TAG, -1);</span>

		// Make sure you do this after experience and location stuff.
<span class="nc" id="L4581">		changeWorkType(xr.getType(spec, WORK_TYPE_TAG, GoodsType.class, null));</span>
<span class="nc" id="L4582">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void readChildren(FreeColXMLReader xr) throws XMLStreamException {
		// Clear containers.
<span class="nc bnc" id="L4590" title="All 2 branches missed.">		if (getGoodsContainer() != null)</span>
<span class="nc" id="L4591">			getGoodsContainer().removeAll();</span>
<span class="nc" id="L4592">		equipment.clear();</span>
<span class="nc" id="L4593">		workImprovement = null;</span>

<span class="nc" id="L4595">		super.readChildren(xr);</span>

		// @compat 0.10.x
<span class="nc bnc" id="L4598" title="All 2 branches missed.">		if (roleCount &lt; 0) {</span>
			// If roleCount was not present, set it from equipment
<span class="nc" id="L4600">			final Specification spec = getSpecification();</span>
<span class="nc" id="L4601">			Role role = spec.getDefaultRole();</span>
<span class="nc" id="L4602">			boolean horses = false, muskets = false;</span>
<span class="nc" id="L4603">			int count = 1;</span>
<span class="nc bnc" id="L4604" title="All 2 branches missed.">			for (EquipmentType type : equipment.keySet()) {</span>
<span class="nc bnc" id="L4605" title="All 2 branches missed.">				if (&quot;model.equipment.horses&quot;.equals(type.getId())</span>
<span class="nc bnc" id="L4606" title="All 2 branches missed.">						|| &quot;model.equipment.indian.horses&quot;.equals(type.getId())) {</span>
<span class="nc" id="L4607">					horses = true;</span>
<span class="nc bnc" id="L4608" title="All 2 branches missed.">				} else if (&quot;model.equipment.muskets&quot;.equals(type.getId())</span>
<span class="nc" id="L4609">						|| &quot;model.equipment.indian.muskets&quot;</span>
<span class="nc bnc" id="L4610" title="All 2 branches missed.">								.equals(type.getId())) {</span>
<span class="nc" id="L4611">					muskets = true;</span>
<span class="nc" id="L4612">				} else {</span>
<span class="nc" id="L4613">					role = type.getRole();</span>
<span class="nc bnc" id="L4614" title="All 2 branches missed.">					if (&quot;model.equipment.tools&quot;.equals(type.getId())) {</span>
<span class="nc" id="L4615">						count = equipment.getCount(type);</span>
					}
				}
			}
<span class="nc bnc" id="L4619" title="All 4 branches missed.">			if (horses &amp;&amp; muskets) {</span>
<span class="nc bnc" id="L4620" title="All 2 branches missed.">				if (owner.isIndian()) {</span>
<span class="nc" id="L4621">					role = spec.getRole(&quot;model.role.nativeDragoon&quot;);</span>
<span class="nc bnc" id="L4622" title="All 4 branches missed.">				} else if (owner.isREF() &amp;&amp; hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4623">					role = spec.getRole(&quot;model.role.cavalry&quot;);</span>
<span class="nc" id="L4624">				} else {</span>
<span class="nc" id="L4625">					role = spec.getRole(&quot;model.role.dragoon&quot;);</span>
				}
<span class="nc bnc" id="L4627" title="All 2 branches missed.">			} else if (horses) {</span>
<span class="nc bnc" id="L4628" title="All 2 branches missed.">				if (owner.isIndian()) {</span>
<span class="nc" id="L4629">					role = spec.getRole(&quot;model.role.mountedBrave&quot;);</span>
<span class="nc bnc" id="L4630" title="All 4 branches missed.">				} else if (owner.isREF() &amp;&amp; hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4631">					logger.warning(&quot;Undefined role: REF Scout&quot;);</span>
<span class="nc" id="L4632">				} else {</span>
<span class="nc" id="L4633">					role = spec.getRole(&quot;model.role.scout&quot;);</span>
				}
<span class="nc bnc" id="L4635" title="All 2 branches missed.">			} else if (muskets) {</span>
<span class="nc bnc" id="L4636" title="All 2 branches missed.">				if (owner.isIndian()) {</span>
<span class="nc" id="L4637">					role = spec.getRole(&quot;model.role.armedBrave&quot;);</span>
<span class="nc bnc" id="L4638" title="All 4 branches missed.">				} else if (owner.isREF() &amp;&amp; hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4639">					role = spec.getRole(&quot;model.role.infantry&quot;);</span>
<span class="nc" id="L4640">				} else {</span>
<span class="nc" id="L4641">					role = spec.getRole(&quot;model.role.soldier&quot;);</span>
				}
			}
<span class="nc" id="L4644">			setRoleCount(Math.min(role.getMaximumCount(), count));</span>
<span class="nc" id="L4645">		} else {</span>
			// If roleCount was present, we are now ignoring equipment.
<span class="nc" id="L4647">			equipment.clear();</span>
		}
		// end @compat 0.10.x

		// @compat 0.10.x
		// There was a bug in 0.10.x that did not clear tile
		// improvements after they were complete, leading to units
		// that still had a tile improvement after they had moved
		// away. Consequently when reading such bogus improvements,
		// there is no guarantee that the tile is defined so
		// compatibility code in TileImprovement.readAttributes
		// tolerates null tile references. These are obviously bogus,
		// so drop them.
<span class="nc bnc" id="L4660" title="All 4 branches missed.">		if (workImprovement != null &amp;&amp; workImprovement.getTile() == null) {</span>
<span class="nc" id="L4661">			workImprovement = null;</span>
		}
		// end @compat 0.10.x
<span class="nc" id="L4664">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void readChild(FreeColXMLReader xr) throws XMLStreamException {
<span class="nc" id="L4671">		final Specification spec = getSpecification();</span>
<span class="nc" id="L4672">		final Game game = getGame();</span>
<span class="nc" id="L4673">		final String tag = xr.getLocalName();</span>

		// @compat 0.10.x
<span class="nc bnc" id="L4676" title="All 2 branches missed.">		if (EQUIPMENT_TAG.equals(tag)) {</span>
<span class="nc" id="L4677">			equipment.incrementCount(spec.getEquipmentType(xr.readId()),</span>
<span class="nc" id="L4678">					xr.getAttribute(COUNT_TAG, 0));</span>
<span class="nc" id="L4679">			xr.closeTag(EQUIPMENT_TAG);</span>
			// end @compat 0.10.x

			// @compat 0.10.5
<span class="nc bnc" id="L4683" title="All 2 branches missed.">		} else if (OLD_UNITS_TAG.equals(tag)) {</span>
<span class="nc bnc" id="L4684" title="All 2 branches missed.">			while (xr.nextTag() != XMLStreamConstants.END_ELEMENT) {</span>
<span class="nc" id="L4685">				super.readChild(xr);</span>
			}
			// end @compat 0.10.5

<span class="nc bnc" id="L4689" title="All 2 branches missed.">		} else if (TileImprovement.getTagName().equals(tag)</span>
		// @compat 0.11.3
<span class="nc bnc" id="L4691" title="All 2 branches missed.">				|| OLD_TILE_IMPROVEMENT_TAG.equals(tag)</span>
		// end @compat 0.11.3
		) {
<span class="nc" id="L4694">			workImprovement = xr.readFreeColGameObject(game,</span>
<span class="nc" id="L4695">					TileImprovement.class);</span>

<span class="nc" id="L4697">		} else {</span>
<span class="nc" id="L4698">			super.readChild(xr);</span>
		}
<span class="nc" id="L4700">	}</span>

	/**
	 * Gets a string representation of this unit.
	 *
	 * @param prefix
	 *            A prefix (e.g. &quot;AIUnit&quot;)
	 * @return A string representation of this &lt;code&gt;Unit&lt;/code&gt;.
	 */
	public String toString(String prefix) {
<span class="nc" id="L4710">		StringBuilder sb = new StringBuilder(64);</span>
<span class="nc" id="L4711">		sb.append(&quot;[&quot;).append(prefix).append(getId());</span>
<span class="nc bnc" id="L4712" title="All 2 branches missed.">		if (!isInitialized()) {</span>
<span class="nc" id="L4713">			sb.append(&quot; uninitialized&quot;);</span>
<span class="nc bnc" id="L4714" title="All 2 branches missed.">		} else if (isDisposed()) {</span>
<span class="nc" id="L4715">			sb.append(&quot; disposed&quot;);</span>
<span class="nc" id="L4716">		} else {</span>
<span class="nc" id="L4717">			sb.append(&quot; &quot;).append(lastPart(owner.getNationId(), &quot;.&quot;))</span>
<span class="nc" id="L4718">					.append(&quot; &quot;).append(getType().getSuffix());</span>
<span class="nc bnc" id="L4719" title="All 2 branches missed.">			if (!hasDefaultRole()) {</span>
<span class="nc" id="L4720">				sb.append(&quot;-&quot;).append(getRoleSuffix());</span>
<span class="nc" id="L4721">				int count = getRoleCount();</span>
<span class="nc bnc" id="L4722" title="All 2 branches missed.">				if (count &gt; 1)</span>
<span class="nc" id="L4723">					sb.append(&quot;.&quot;).append(count);</span>
			}
<span class="nc" id="L4725">			sb.append(&quot; &quot;).append(getMovesAsString());</span>
		}
<span class="nc" id="L4727">		sb.append(&quot;]&quot;);</span>
<span class="nc" id="L4728">		return sb.toString();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String toString() {
<span class="nc" id="L4736">		return toString(&quot;&quot;);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getXMLTagName() {
<span class="nc" id="L4744">		return getTagName();</span>
	}

	/**
	 * Gets the tag name of the root element representing this object.
	 *
	 * @return &quot;unit&quot;
	 */
	public static String getTagName() {
<span class="nc" id="L4753">		return &quot;unit&quot;;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span>TestAll (6) (May 17, 2016 2:04:14 AM)</div></body></html>